<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Shellcode 计算器 | Reus09&#39;s Blog</title>
<meta name="keywords" content="pwn">
<meta name="description" content="逆向分析计算器的漏洞利用过程 0x01 实验目的 根据实验软件SCer.exe 和 shellcode代码shellcode2020.mybin，通过win">
<meta name="author" content="Reus09">
<link rel="canonical" href="http://www.reus09.top/posts/tech/shellcode-%E8%AE%A1%E7%AE%97%E5%99%A8/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.40573d180b208ab15c3bf0a170c2ac86aa8ccf179f96f939352198fbee79100e.css" integrity="sha256-QFc9GAsgirFcO/ChcMKshqqMzxeflvk5NSGY&#43;&#43;55EA4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="icon" type="image/png" sizes="16x16" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="icon" type="image/png" sizes="32x32" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="apple-touch-icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="mask-icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Shellcode 计算器" />
<meta property="og:description" content="逆向分析计算器的漏洞利用过程 0x01 实验目的 根据实验软件SCer.exe 和 shellcode代码shellcode2020.mybin，通过win" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.reus09.top/posts/tech/shellcode-%E8%AE%A1%E7%AE%97%E5%99%A8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-03T22:05:29+00:00" />
<meta property="article:modified_time" content="2022-09-11T16:10:58+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Shellcode 计算器"/>
<meta name="twitter:description" content="逆向分析计算器的漏洞利用过程 0x01 实验目的 根据实验软件SCer.exe 和 shellcode代码shellcode2020.mybin，通过win"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📚文章",
      "item": "http://www.reus09.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "👨🏻‍💻技术",
      "item": "http://www.reus09.top/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Shellcode 计算器",
      "item": "http://www.reus09.top/posts/tech/shellcode-%E8%AE%A1%E7%AE%97%E5%99%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Shellcode 计算器",
  "name": "Shellcode 计算器",
  "description": "逆向分析计算器的漏洞利用过程 0x01 实验目的 根据实验软件SCer.exe 和 shellcode代码shellcode2020.mybin，通过win",
  "keywords": [
    "pwn"
  ],
  "articleBody": "逆向分析计算器的漏洞利用过程 0x01 实验目的 根据实验软件SCer.exe 和 shellcode代码shellcode2020.mybin，通过windbg逆向分析弹出计算器的漏洞利用详细过程 根据实验软件shellcode2020.exe，通过Ollydbg逆向分析弹出计算器的漏洞利用详细过程。 分析两者区别。 0x02 试验工具 windbg Ollydbg IDA_PRO 因为Windows xp sp3下的Windbg微软将其在线Symbol符号下架，导致Windbg调试过程中，部分关键函数为乱码，无法正常分析，故借鉴Ida 实验环境 Windows xp sp3 0x03 windbg 调试 Scer.exe 打开Scer.exe，然后将shellcode.txt.mybin附加到程序，可以发现计算器可以正常打开。\n需要对Scer.exe进行动态调试分析，为了调试分析植入的shellcode,我们在shellcode.txt.bin前加上字节0xCC\n然后在windbg中附加 Scer.exe的进程。\n这里程序会停在系统代码区域，我们要进入用户代码里面。 WinDbg里有个伪寄存器叫$exentry，里面记录了程序的入口点。所以我们只要在命令输入栏里输入bp $exentry 然后执行命令g即可进入用户程序入口。 这里结合IDA_pro，F5反编译可以看到 这里实现了程序的初始化，就不在过多分析。 这里通过IDA_PRO，找到我们加载核心代码shellcode 的首地址。\n首先shift+F12查看字符串，找到字符串状态:0x%0.8x 已载入shellcode,即将开始执行...，一路反跟踪函数返回，找到该段功能的首地址为：0x401830 也就是说在此段代码中，我们实现了向程序中输入shellcode后，程序如何处理shellcode以及如何跳转到shellcode的过程 在windbg 下 设置断点 bp 0x401830\n加载我们的shellcode 后，就可以在windbg中调试 看到程序怎么将shellcode存放起来并执行。 然后输入pc跳转到下一个call 指令，然后步入，这个函数为 CreateFileA。\n发现该函数功能实现了创建一个线程———-打开文件夹，即我们的shellcode文件。 继续pc跳转到下一个函数地址，这个函数为 VirtualAlloc\n这里查看一下VirtualAlloc函数的结构\n1 2 3 4 5 6 LPVOID VirtualAlloc{ LPVOID lpAddress, // 要分配的内存区域的地址 DWORD dwSize, // 分配的大小 DWORD flAllocationType, // 分配的类型 DWORD flProtect // 该内存的初始保护属性 }; 并且与调入函数前传入的参数相结合对比，\n发现 ebx 存取的是 我们shellcode 的字节长度，esi存放的是 程序给 shellcode 分配的动态地址。\n程序执行完毕后，很明显可以发现了esi 存取的 地址为 0xb40000\n这里就实现了为 shellcode的存取 提前分配好了 动态地址， 起始地址为 0xb40000\n继续pc跳转到下一个call函数，该函数名字为 ReadFile\n这里查看一下VirtualAlloc函数的结构\n1 2 3 4 5 6 7 8 9 BOOL ReadFile( HANDLE hFile, //文件的句柄 LPVOID lpBuffer, //用于保存读入数据的一个缓冲区 DWORD nNumberOfBytesToRead, //要读入的字节数 LPDWORD lpNumberOfBytesRead, //指向实际读取字节数的指针 LPOVERLAPPED lpOverlapped //如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。 //该结构定义了一次异步读取操作。否则，应将这个参数设为NULL ); 此时的寄存器情况：\n将函数结构 与 传参前的 汇编语言进行 对比。\n可以发现函数实现了在地址为esi :: 0xb40000 的缓冲区 存取了 长度为27 字节的 shellcode。\n继续pc进行到sleep函数。\n因为要等待此时的线程完成。 继续p指令 单步跳过，一直到\n此段整体汇编代码对应用IDA_Pro显示\nmov bp+ms_exc.registration.TryLevel], 0 ; 进入第一个__try域,TryLevel=0\nmov ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh ; 离开第一个__try域，TryLevel=TRYLEVEL_NONE (-2)\n所以此段为 try_except 的过程。\n然后发现存在汇编语句call eax\ncall eax 来自 [ebp + var_24]\n追踪发现 [ebp+var_24]存放的是esi的地址，即0xb40000 因此这段代码，就是程序进入预先分配好的动态内存区(里面存有shellcode）的入口。\n进入函数，分析shellcode。\n程序执行到0xb40001跳转到地址0xb40019，然后发现在地址0xb40019的 jmp 指令跳转到 0xb40003\n这里解释么要先call 跳转到 0xb40019然后再回到0xb40003\ncall/pop指令 Shellcode可以通过在一个call指令后立即执行pop指令，将上一刻压入栈中的指令地址载入到寄存器中，从而获取到shellcode起始的内存地址。 原理就是：call 指令实际上就是 先将该函数的下一个地址压入栈中，然后跳转到目的地址。跳转之后再将其pop出来，这样就达到了ebx 存放 地址0xb4001e的作用。 这里通过call 0xb40003指令调用完之后对栈的分析，可以看出。 显然，栈最顶层为calc.exe 存放的地址。 然后开始 pop ebx ，将 eax 清零。\n然后向栈中压入 ebx,eax。 ebx此时存放的地址为0xb4001e即字符串\\x63\\x61x6c\\x63\\x2e\\x65\\x78\\x65对应的calc.exe\n将函数kernel32!WinExec地址传给ebx。\n上面两个压栈相当于 对下面的函数 kernel32!WinExec进行传参。\n1 2 UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow ); 这样就相当于调用函数 winExec(\"calc.exe\",0)来打开计算器。\n函数调用完成后。将eax置0，然后入栈，将函数kernel32!ExitProcess地址传给ebx。相当于向函数kernel32!ExitProcess传入参数，结束调用的进程及其所有的线程windows函数。\nshellcode分析完毕。\n在命令中输入g，即可弹出计算器。\n0x04 Ollydbg 调试 shellcode2020.exe 直接执行shellcode2020.exe会直接弹出计算器。\n动态分析前:\n通过IDA_Pro 可以直接定位到 main函数地址为 : 0x401290 在Ollydbg中设置断点0x401290,然后运行程序跳转到该地址\n1 2 3 4 5 6 7 8 9 10 push ebp mov ebp,esp 更新函数栈帧 sub esp,8 and esp,FFFFFFF0 mov eax,0 add eax,0f add eax,0f shr eax,4 shl eax,4 将 (eax + 0f + 0f )先左移一位，后右移一位，结果为00000010 然后进入到地址为0x401710的函数，结合IDA，该函数为alloca函数，产生函数指针。\n1 2 3 4 5 6 7 8 原型： void * __cdecl alloca(size_t); 参数： size_t: 申请分配内存的尺寸 返回值： void*: 分配到的内存地址 alloca与malloc,calloc,realloc类似,需要注意的是它申请的是“栈(stack)”空间的内存，用完会在退出栈时自动释放，无需手动释放。 alloca不宜使用在必须广泛移植的程序中, 因为有些机器不一定有传统意义上的\"堆栈\" 进入函数0x4013b0，执行加载函数，将shellcode加载到代码区。\n然后设置断点 0x4012ba，然后单步步入\n发现dword ptr[ebp - 4]被赋值为地址0x402000 观察IDA，发现地址0x40200的地方存取的数据为evil数组，即shellcode存放地址。 同时0x402000也是文件执行过程中，data端的起始位置。 步入，查看shellcode。\n发现大致流程和windbg分析过程一样。\n通过call和pop结合运用，将ebx赋值为 地址0x40201d ebx此时存放的为字符串calc.exe 然后同样的压栈操作，调用函数Kernel32!WinExec进行执行计算器。\n执行完毕后，又将eax置0 ，将函数kernel32!ExitProcess的地址传给ebx,调用ebx地址所在的程序，即ExitProcess(‘0’)，退出程序。\n0x05 总结(区别) Scer.exe创造一个新的线程，然后通过读取文件内容作为shellcode，并通过VirtualAlloc申请内存，xp里面这个内存地址均为0xb40000并且用esi保存这个地址，然后ReadFile即在虚拟地址0xb40000中写入shellcode，然后通过format,update等函数shellcode进行转换，最后地址将其作为一个函数指针，进行调用，进入shellcode。 shellcode2020.exe则是在文件的.data端 存放我们的shellcode。通过函数alloca来在堆上申请内存，并且用函数指针对其调用，最后调用.data的起始地址，运行我们构造的shellcode,可以运行计算器。 因此两者的区别：一个是从外部植入shellcode，将其加载到内存中，另一个是程序本身自带的shellcode，通过构造函数指针来执行shellcode。 ",
  "wordCount" : "3439",
  "inLanguage": "en",
  "datePublished": "2021-11-03T22:05:29Z",
  "dateModified": "2022-09-11T16:10:58+08:00",
  "author":[{
    "@type": "Person",
    "name": "Reus09"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://www.reus09.top/posts/tech/shellcode-%E8%AE%A1%E7%AE%97%E5%99%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Reus09's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://www.reus09.top" accesskey="h" title="Reus09&#39;s Blog (Alt + H)">Reus09&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://www.reus09.top/search" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/posts" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/categories" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/tags" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/about" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://www.reus09.top">Home</a>&nbsp;»&nbsp;<a href="http://www.reus09.top/posts/">📚文章</a>&nbsp;»&nbsp;<a href="http://www.reus09.top/posts/tech/">👨🏻‍💻技术</a></div>
    <h1 class="post-title">
      Shellcode 计算器
    </h1>
    <div class="post-meta"><span title='2021-11-03 22:05:29 +0000 UTC'>2021-11-03</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Reus09

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e9%80%86%e5%90%91%e5%88%86%e6%9e%90%e8%ae%a1%e7%ae%97%e5%99%a8%e7%9a%84%e6%bc%8f%e6%b4%9e%e5%88%a9%e7%94%a8%e8%bf%87%e7%a8%8b" aria-label="逆向分析计算器的漏洞利用过程">逆向分析计算器的漏洞利用过程</a><ul>
                            
                    <li>
                        <a href="#0x01-%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84" aria-label="0x01 实验目的">0x01 实验目的</a><ul>
                            <ul>
                            <ul>
                            
                    <li>
                        <a href="#%e6%a0%b9%e6%8d%ae%e5%ae%9e%e9%aa%8c%e8%bd%af%e4%bb%b6scerexe-%e5%92%8c-shellcode%e4%bb%a3%e7%a0%81shellcode2020mybin%e9%80%9a%e8%bf%87windbg%e9%80%86%e5%90%91%e5%88%86%e6%9e%90%e5%bc%b9%e5%87%ba%e8%ae%a1%e7%ae%97%e5%99%a8%e7%9a%84%e6%bc%8f%e6%b4%9e%e5%88%a9%e7%94%a8%e8%af%a6%e7%bb%86%e8%bf%87%e7%a8%8b" aria-label="根据实验软件SCer.exe 和 shellcode代码shellcode2020.mybin，通过windbg逆向分析弹出计算器的漏洞利用详细过程">根据实验软件SCer.exe 和 shellcode代码shellcode2020.mybin，通过windbg逆向分析弹出计算器的漏洞利用详细过程</a></li>
                    <li>
                        <a href="#%e6%a0%b9%e6%8d%ae%e5%ae%9e%e9%aa%8c%e8%bd%af%e4%bb%b6shellcode2020exe%e9%80%9a%e8%bf%87ollydbg%e9%80%86%e5%90%91%e5%88%86%e6%9e%90%e5%bc%b9%e5%87%ba%e8%ae%a1%e7%ae%97%e5%99%a8%e7%9a%84%e6%bc%8f%e6%b4%9e%e5%88%a9%e7%94%a8%e8%af%a6%e7%bb%86%e8%bf%87%e7%a8%8b" aria-label="根据实验软件shellcode2020.exe，通过Ollydbg逆向分析弹出计算器的漏洞利用详细过程。">根据实验软件shellcode2020.exe，通过Ollydbg逆向分析弹出计算器的漏洞利用详细过程。</a></li>
                    <li>
                        <a href="#%e5%88%86%e6%9e%90%e4%b8%a4%e8%80%85%e5%8c%ba%e5%88%ab" aria-label="分析两者区别。">分析两者区别。</a></li></ul>
                        </ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#0x02-%e8%af%95%e9%aa%8c%e5%b7%a5%e5%85%b7" aria-label="0x02 试验工具">0x02 试验工具</a><ul>
                            <ul>
                            <ul>
                            
                    <li>
                        <a href="#windbg" aria-label="windbg">windbg</a></li>
                    <li>
                        <a href="#ollydbg" aria-label="Ollydbg">Ollydbg</a></li>
                    <li>
                        <a href="#ida_pro" aria-label="IDA_PRO">IDA_PRO</a></li>
                    <li>
                        <a href="#%e5%ae%9e%e9%aa%8c%e7%8e%af%e5%a2%83" aria-label="实验环境">实验环境</a></li>
                    <li>
                        <a href="#windows-xp-sp3" aria-label="Windows xp sp3">Windows xp sp3</a></li></ul>
                        </ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#0x03-windbg-%e8%b0%83%e8%af%95-scerexe" aria-label="0x03 windbg 调试 Scer.exe">0x03 windbg 调试 Scer.exe</a></li>
                    <li>
                        <a href="#0x04-ollydbg-%e8%b0%83%e8%af%95-shellcode2020exe" aria-label="0x04 Ollydbg 调试 shellcode2020.exe">0x04 Ollydbg 调试 shellcode2020.exe</a></li>
                    <li>
                        <a href="#0x05-%e6%80%bb%e7%bb%93%e5%8c%ba%e5%88%ab" aria-label="0x05 总结(区别)">0x05 总结(区别)</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="逆向分析计算器的漏洞利用过程">逆向分析计算器的漏洞利用过程<a hidden class="anchor" aria-hidden="true" href="#逆向分析计算器的漏洞利用过程">#</a></h1>
<h2 id="0x01-实验目的">0x01 实验目的<a hidden class="anchor" aria-hidden="true" href="#0x01-实验目的">#</a></h2>
<ul>
<li>
<h5 id="根据实验软件scerexe-和-shellcode代码shellcode2020mybin通过windbg逆向分析弹出计算器的漏洞利用详细过程">根据实验软件SCer.exe 和 shellcode代码shellcode2020.mybin，通过windbg逆向分析弹出计算器的漏洞利用详细过程<a hidden class="anchor" aria-hidden="true" href="#根据实验软件scerexe-和-shellcode代码shellcode2020mybin通过windbg逆向分析弹出计算器的漏洞利用详细过程">#</a></h5>
</li>
<li>
<h5 id="根据实验软件shellcode2020exe通过ollydbg逆向分析弹出计算器的漏洞利用详细过程">根据实验软件shellcode2020.exe，通过Ollydbg逆向分析弹出计算器的漏洞利用详细过程。<a hidden class="anchor" aria-hidden="true" href="#根据实验软件shellcode2020exe通过ollydbg逆向分析弹出计算器的漏洞利用详细过程">#</a></h5>
</li>
<li>
<h5 id="分析两者区别">分析两者区别。<a hidden class="anchor" aria-hidden="true" href="#分析两者区别">#</a></h5>
</li>
</ul>
<h2 id="0x02-试验工具">0x02 试验工具<a hidden class="anchor" aria-hidden="true" href="#0x02-试验工具">#</a></h2>
<ul>
<li>
<h5 id="windbg">windbg<a hidden class="anchor" aria-hidden="true" href="#windbg">#</a></h5>
</li>
<li>
<h5 id="ollydbg">Ollydbg<a hidden class="anchor" aria-hidden="true" href="#ollydbg">#</a></h5>
</li>
<li>
<h5 id="ida_pro">IDA_PRO<a hidden class="anchor" aria-hidden="true" href="#ida_pro">#</a></h5>
<ul>
<li>因为Windows xp sp3下的Windbg微软将其在线Symbol符号下架，导致Windbg调试过程中，部分关键函数为乱码，无法正常分析，故借鉴Ida</li>
</ul>
</li>
<li>
<h5 id="实验环境">实验环境<a hidden class="anchor" aria-hidden="true" href="#实验环境">#</a></h5>
<ul>
<li>
<h5 id="windows-xp-sp3">Windows xp sp3<a hidden class="anchor" aria-hidden="true" href="#windows-xp-sp3">#</a></h5>
</li>
</ul>
</li>
</ul>
<h2 id="0x03-windbg-调试-scerexe">0x03 windbg 调试 Scer.exe<a hidden class="anchor" aria-hidden="true" href="#0x03-windbg-调试-scerexe">#</a></h2>
<ul>
<li>
<p>打开Scer.exe，然后将shellcode.txt.mybin附加到程序，可以发现计算器可以正常打开。</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210929234755283.png" alt="image-20210929234755283"  />
</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210929234801883.png" alt="image-20210929234801883"  />
</li>
</ul>
</li>
<li>
<p>需要对Scer.exe进行动态调试分析，为了调试分析植入的shellcode,我们在shellcode.txt.bin前加上字节<code>0xCC</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210929235018201.png" alt="image-20210929235018201"  />
</li>
</ul>
</li>
<li>
<p>然后在windbg中附加 Scer.exe的进程。</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210929235237150.png" alt="image-20210929235237150"  />
</li>
<li>这里程序会停在系统代码区域，我们要进入用户代码里面。</li>
<li>WinDbg里有个伪寄存器叫$exentry，里面记录了程序的入口点。所以我们只要在命令输入栏里输入<code>bp $exentry</code></li>
<li>然后执行命令<code>g</code>即可进入用户程序入口。</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210929235440289.png" alt="image-20210929235440289"  />
</li>
<li>这里结合IDA_pro，<code>F5</code>反编译可以看到
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930000700637.png" alt="image-20210930000700637"  />
</li>
<li>这里实现了程序的初始化，就不在过多分析。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>这里通过IDA_PRO，找到我们加载核心代码shellcode 的首地址。</p>
<ul>
<li>首先<code>shift+F12</code>查看字符串，找到字符串<code>状态:0x%0.8x 已载入shellcode,即将开始执行...</code>，一路反跟踪函数返回，找到该段功能的首地址为：<code>0x401830</code></li>
<li>也就是说在此段代码中，我们实现了向程序中输入shellcode后，程序如何处理shellcode以及如何跳转到shellcode的过程</li>
</ul>
</li>
<li>
<p>在windbg 下 设置断点 <code>bp 0x401830</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930001010334.png" alt="image-20210930001010334"  />
</li>
<li>加载我们的shellcode 后，就可以在windbg中调试 看到程序怎么将shellcode存放起来并执行。</li>
</ul>
</li>
<li>
<p>然后输入<code>pc</code>跳转到下一个call 指令，然后步入，这个函数为 <code>CreateFileA</code>。</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930001323214.png" alt="image-20210930001323214"  />
</li>
<li>发现该函数功能实现了创建一个线程&mdash;&mdash;&mdash;-打开文件夹，即我们的shellcode文件。</li>
</ul>
</li>
<li>
<p>继续<code>pc</code>跳转到下一个函数地址，这个函数为 <code>VirtualAlloc</code></p>
<ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930001505973.png" alt="image-20210930001505973"  />
</p>
</li>
<li>
<p>这里查看一下<code>VirtualAlloc函数</code>的结构</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LPVOID VirtualAlloc{
</span></span><span style="display:flex;"><span>	LPVOID lpAddress, <span style="color:#007f7f">// 要分配的内存区域的地址
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	DWORD dwSize, <span style="color:#007f7f">// 分配的大小
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	DWORD flAllocationType, <span style="color:#007f7f">// 分配的类型
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	DWORD flProtect <span style="color:#007f7f">// 该内存的初始保护属性
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>};
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930001850024.png" alt="image-20210930001850024"  />
</p>
</li>
<li>
<p>并且与调入函数前传入的参数相结合对比，</p>
</li>
<li>
<p>发现 ebx 存取的是 我们shellcode 的字节长度，esi存放的是 程序给 shellcode 分配的动态地址。</p>
</li>
</ul>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930002055336.png" alt="image-20210930002055336"  />
</p>
</li>
<li>
<p>程序执行完毕后，很明显可以发现了esi 存取的 地址为 <code>0xb40000</code></p>
</li>
<li>
<p>这里就实现了为 shellcode的存取 提前分配好了 动态地址， 起始地址为 <code>0xb40000</code></p>
</li>
</ul>
</li>
<li>
<p>继续<code>pc</code>跳转到下一个call函数，该函数名字为 <code>ReadFile</code></p>
<ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930002506167.png" alt="image-20210930002506167"  />
</p>
</li>
<li>
<p>这里查看一下<code>VirtualAlloc函数</code>的结构</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>BOOL ReadFile(
</span></span><span style="display:flex;"><span>    HANDLE hFile,                                    <span style="color:#007f7f">//文件的句柄
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    LPVOID lpBuffer,                                <span style="color:#007f7f">//用于保存读入数据的一个缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    DWORD nNumberOfBytesToRead,    <span style="color:#007f7f">//要读入的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    LPDWORD lpNumberOfBytesRead,    <span style="color:#007f7f">//指向实际读取字节数的指针
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    LPOVERLAPPED lpOverlapped
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//该结构定义了一次异步读取操作。否则，应将这个参数设为NULL
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>);
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930002546255.png" alt="image-20210930002546255"  />
</p>
</li>
<li>
<p>此时的寄存器情况：</p>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930002800541.png" alt="image-20210930002800541"  />
</p>
</li>
<li>
<p>将函数结构 与 传参前的 汇编语言进行 对比。</p>
</li>
</ul>
</li>
<li>
<p>可以发现函数实现了在地址为<code>esi :: 0xb40000</code> 的缓冲区 存取了 长度为27 字节的 shellcode。</p>
</li>
</ul>
</li>
<li>
<p>继续<code>pc</code>进行到sleep函数。</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930003021502.png" alt="image-20210930003021502"  />
</li>
<li>因为要等待此时的线程完成。</li>
</ul>
</li>
<li>
<p>继续<code>p</code>指令 单步跳过，一直到</p>
<ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930003255306.png" alt="image-20210930003255306"  />
</p>
</li>
<li>
<p>此段整体汇编代码对应用IDA_Pro显示</p>
<ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930003409194.png" alt="image-20210930003409194"  />
</p>
</li>
<li>
<p><code>mov bp+ms_exc.registration.TryLevel], 0 ; 进入第一个__try域,TryLevel=0</code></p>
</li>
<li>
<p><code>mov ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh ; 离开第一个__try域，TryLevel=TRYLEVEL_NONE (-2)</code></p>
</li>
<li>
<p>所以此段为 <code>try_except </code>的过程。</p>
</li>
<li>
<p>然后发现存在汇编语句<code>call eax</code></p>
</li>
<li>
<p><code>call eax</code> 来自 <code>[ebp + var_24]</code></p>
<ul>
<li>追踪发现</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930003729944.png" alt="image-20210930003729944"  />
</li>
<li><code>[ebp+var_24]</code>存放的是<code>esi</code>的地址，即<code>0xb40000</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>因此这段代码，就是程序进入预先分配好的动态内存区(里面存有shellcode）的入口。</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930004003753.png" alt="image-20210930004003753"  />
</p>
</li>
</ul>
</li>
<li>
<p>进入函数，分析shellcode。</p>
<ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930004052803.png" alt="image-20210930004052803"  />
</p>
</li>
<li>
<p>程序执行到<code>0xb40001</code>跳转到地址<code>0xb40019</code>，然后发现在地址<code>0xb40019</code>的 jmp 指令跳转到 <code>0xb40003</code></p>
</li>
<li>
<p>这里解释么要先call 跳转到 <code>0xb40019</code>然后再回到<code>0xb40003</code></p>
<ul>
<li>call/pop指令</li>
<li>Shellcode可以通过在一个call指令后立即执行pop指令，将上一刻压入栈中的指令地址载入到寄存器中，从而获取到shellcode起始的内存地址。</li>
<li>原理就是：call 指令实际上就是 先将该函数的下一个地址压入栈中，然后跳转到目的地址。跳转之后再将其pop出来，这样就达到了ebx 存放 地址<code>0xb4001e</code>的作用。</li>
<li>这里通过<code>call 0xb40003</code>指令调用完之后对栈的分析，可以看出。
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930005834839.png" alt="image-20210930005834839"  />
</li>
<li>显然，栈最顶层为calc.exe 存放的地址。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>然后开始 pop ebx ，将 eax 清零。</p>
</li>
<li>
<p>然后向栈中压入 ebx,eax。 ebx此时存放的地址为<code>0xb4001e</code>即字符串<code>\x63\x61x6c\x63\x2e\x65\x78\x65</code>对应的<code>calc.exe</code></p>
</li>
<li>
<p>将函数<code>kernel32!WinExec</code>地址传给ebx。</p>
</li>
<li>
<p>上面两个压栈相当于 对下面的函数 <code>kernel32!WinExec</code>进行传参。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>UINT WinExec(  LPCSTR lpCmdLine,  
</span></span><span style="display:flex;"><span>             UINT   uCmdShow );
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>这样就相当于调用函数 <code>winExec(&quot;calc.exe&quot;,0)</code>来打开计算器。</p>
</li>
<li>
<p>函数调用完成后。将eax置0，然后入栈，将函数<code>kernel32!ExitProcess</code>地址传给ebx。相当于向函数<code>kernel32!ExitProcess</code>传入参数，结束调用的进程及其所有的线程windows函数。</p>
</li>
</ul>
</li>
<li>
<p>shellcode分析完毕。</p>
</li>
<li>
<p>在命令中输入<code>g</code>，即可弹出计算器。</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930010258154.png" alt="image-20210930010258154"  />
</li>
</ul>
</li>
</ul>
<h2 id="0x04-ollydbg-调试-shellcode2020exe">0x04 Ollydbg 调试 shellcode2020.exe<a hidden class="anchor" aria-hidden="true" href="#0x04-ollydbg-调试-shellcode2020exe">#</a></h2>
<ul>
<li>
<p>直接执行shellcode2020.exe会直接弹出计算器。</p>
</li>
<li>
<p>动态分析前:</p>
<ul>
<li>通过IDA_Pro 可以直接定位到 main函数地址为 : <code>0x401290</code></li>
</ul>
</li>
<li>
<p>在Ollydbg中设置断点<code>0x401290</code>,然后运行程序跳转到该地址</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930012008965.png" alt="image-20210930012008965"  />
</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>push ebp 
</span></span><span style="display:flex;"><span>mov ebp,esp 更新函数栈帧
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sub esp,8
</span></span><span style="display:flex;"><span>and esp,FFFFFFF0
</span></span><span style="display:flex;"><span>mov eax,0
</span></span><span style="display:flex;"><span>add eax,0f
</span></span><span style="display:flex;"><span>add eax,0f
</span></span><span style="display:flex;"><span>shr eax,4
</span></span><span style="display:flex;"><span>shl eax,4  将 (eax + 0f + 0f )先左移一位，后右移一位，结果为00000010
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>然后进入到地址为<code>0x401710</code>的函数，结合IDA，该函数为alloca函数，产生函数指针。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>原型：
</span></span><span style="display:flex;"><span>void * __cdecl alloca(size_t);
</span></span><span style="display:flex;"><span>参数：
</span></span><span style="display:flex;"><span>size_t: 申请分配内存的尺寸
</span></span><span style="display:flex;"><span>返回值：
</span></span><span style="display:flex;"><span>void*: 分配到的内存地址
</span></span><span style="display:flex;"><span>alloca与malloc,calloc,realloc类似,需要注意的是它申请的是“栈(stack)”空间的内存，用完会在退出栈时自动释放，无需手动释放。
</span></span><span style="display:flex;"><span>alloca不宜使用在必须广泛移植的程序中, 因为有些机器不一定有传统意义上的&#34;堆栈&#34;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>进入函数<code>0x4013b0</code>，执行加载函数，将shellcode加载到代码区。</p>
</li>
<li>
<p>然后设置断点 <code>0x4012ba</code>，然后单步步入</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930020613037.png" alt="image-20210930020613037"  />
</li>
<li>发现<code>dword ptr[ebp - 4]</code>被赋值为地址<code>0x402000</code></li>
<li>观察IDA，发现地址<code>0x40200</code>的地方存取的数据为evil数组，即shellcode存放地址。</li>
<li>同时<code>0x402000</code>也是文件执行过程中，data端的起始位置。</li>
</ul>
</li>
<li>
<p>步入，查看shellcode。</p>
<ul>
<li>
<p>发现大致流程和windbg分析过程一样。</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930020953402.png" alt="image-20210930020953402"  />
</li>
<li>通过call和pop结合运用，将ebx赋值为 地址<code>0x40201d</code>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930021121847.png" alt="image-20210930021121847"  />
</li>
<li>ebx此时存放的为字符串<code>calc.exe</code></li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930021514723.png" alt="image-20210930021514723"  />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>然后同样的压栈操作，调用函数<code>Kernel32!WinExec</code>进行执行计算器。</p>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20210930022642197.png" alt="image-20210930022642197"  />
</p>
</li>
<li>
<p>执行完毕后，又将eax置0 ，将函数<code>kernel32!ExitProcess</code>的地址传给ebx,调用ebx地址所在的程序，即ExitProcess(&lsquo;0&rsquo;)，退出程序。</p>
</li>
</ul>
</li>
</ul>
<h2 id="0x05-总结区别">0x05 总结(区别)<a hidden class="anchor" aria-hidden="true" href="#0x05-总结区别">#</a></h2>
<ul>
<li>Scer.exe创造一个新的线程，然后通过读取文件内容作为shellcode，并通过<code>VirtualAlloc</code>申请内存，xp里面这个内存地址均为<code>0xb40000</code>并且用esi保存这个地址，然后<code>ReadFile</code>即在虚拟地址<code>0xb40000</code>中写入shellcode，然后通过<code>forma</code>t,<code>update</code>等函数shellcode进行转换，最后地址将其作为一个函数指针，进行调用，进入shellcode。</li>
<li>shellcode2020.exe则是在文件的.data端 存放我们的shellcode。通过函数<code>alloca</code>来在堆上申请内存，并且用函数指针对其调用，最后调用.data的起始地址，运行我们构造的shellcode,可以运行计算器。</li>
<li>因此两者的区别：一个是从外部植入shellcode，将其加载到内存中，另一个是程序本身自带的shellcode，通过构造函数指针来执行shellcode。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://www.reus09.top/tags/pwn/">pwn</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://www.reus09.top/posts/tech/rop/">
    <span class="title">« Prev</span>
    <br>
    <span>Rop</span>
  </a>
  <a class="next" href="http://www.reus09.top/posts/tech/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">
    <span class="title">Next »</span>
    <br>
    <span>格式化字符串</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="http://www.reus09.top">Reus09&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
