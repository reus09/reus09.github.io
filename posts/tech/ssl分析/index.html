<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ssl分析 | Reus09&#39;s Blog</title>
<meta name="keywords" content="ssl">
<meta name="description" content="0x01 实验目的 SSL/TLS协议分析。 用wireshark抓包，分析SSL/TLS连接建立的四个阶段。 OpenSSL安装、配置和测试。 安装配置O">
<meta name="author" content="Reus09">
<link rel="canonical" href="http://www.reus09.top/posts/tech/ssl%E5%88%86%E6%9E%90/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.40573d180b208ab15c3bf0a170c2ac86aa8ccf179f96f939352198fbee79100e.css" integrity="sha256-QFc9GAsgirFcO/ChcMKshqqMzxeflvk5NSGY&#43;&#43;55EA4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="icon" type="image/png" sizes="16x16" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="icon" type="image/png" sizes="32x32" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="apple-touch-icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<link rel="mask-icon" href="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Ssl分析" />
<meta property="og:description" content="0x01 实验目的 SSL/TLS协议分析。 用wireshark抓包，分析SSL/TLS连接建立的四个阶段。 OpenSSL安装、配置和测试。 安装配置O" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.reus09.top/posts/tech/ssl%E5%88%86%E6%9E%90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-01T21:22:48+00:00" />
<meta property="article:modified_time" content="2022-09-11T16:15:05+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ssl分析"/>
<meta name="twitter:description" content="0x01 实验目的 SSL/TLS协议分析。 用wireshark抓包，分析SSL/TLS连接建立的四个阶段。 OpenSSL安装、配置和测试。 安装配置O"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📚文章",
      "item": "http://www.reus09.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "👨🏻‍💻技术",
      "item": "http://www.reus09.top/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Ssl分析",
      "item": "http://www.reus09.top/posts/tech/ssl%E5%88%86%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ssl分析",
  "name": "Ssl分析",
  "description": "0x01 实验目的 SSL/TLS协议分析。 用wireshark抓包，分析SSL/TLS连接建立的四个阶段。 OpenSSL安装、配置和测试。 安装配置O",
  "keywords": [
    "ssl"
  ],
  "articleBody": "0x01 实验目的 SSL/TLS协议分析。\n用wireshark抓包，分析SSL/TLS连接建立的四个阶段。 OpenSSL安装、配置和测试。\n安装配置OpenSSL。 配置SSL测试环境，能够在安全连接上发送数据。 0x02 TLS协议分析 源IP：\n源IP : 10.122.201.99 目的域名:www.baidu.com\n源IP : 110.242.68.4 TLS 握手的目的\nTCP 三次握手结束和服务器成功连接后，客户端就开始发起TLS连接，首先会进入TLS握手阶段。TLS握手阶段目的：\n协商加密密钥\n用来对后面的 HTTP 协议等应用协议内容进行加密。这个密钥又称为主密钥，为加密算法的密钥。 协商加密算法\n为了能够提供效率，使用对称密钥。对称加密使用的是位运算，速度快，甚至可以硬件加速。非对称加密比如 RSA，使用了大数乘法等，整体会比较慢。对称加密只要密钥没有泄漏，那也是非常安全的。这也是后面 SSL 握手协议要确保的。 验证身份及数据完整性\n通常情况下，只要验证服务端身份。特殊情况下，比如一些安全级别高的应用场景，还要验证客户端身份。服务端会返回证书链，有根 CA 证书在里头。通过证书的链式担保，可以确认服务端是否是可信任的。同时，在握手期间，公钥传输成功后，还会对某些信息进行数字签名，确保数据没有被篡改且身份无误。TLS握手阶段一般流程（TLS握手的流程并不是一成不变的，根据实际的应用场景来，主要有三种）： 只验证服务端\n这个用三个阶段就完成握手，此次Wireshark的请求也是这样。一般的网络请求也仅仅到这个程度。 验证服务端和客户端\n在安全性要求较高的场景，服务端也要验证客户端的身份。方式也是发证书证明自己。 恢复原有会话\n这个属于HTTPS 优化的范畴。使用 Session Ticket 或者 Session ID 机制恢复之前已经完成握手的会话。这个是可以允许在不同的 TCP 上进行的。因为握手的加密数据已经保存，直接恢复就可以开始传递了。Session Ticket 由客户端保存加密信息，Session ID 的方式由服务端保存加密信息。不过 Session Ticket 在 Android 客户端还没有得到广泛的支持，和具体机型和内置的 OpenSSL 的版本有关。 TLS握手机制图解\nClient Hello\n在Wireshark软件中捕获了访问百度网页数据包，追踪TCP流得到第一个TLS包\n类型 长度 版本 TLS 1.2 也是 SSLv3.2。这是 SSL 客户端能够支持的 SSL 最高版本 随机数\n生成一个32字节随机数（图中的随机数）。最后加密数据用的主密钥，需要客户端和服务端一起协商出来。后面服务端的 Server Hello 阶段也会生成一个随机数。一同用来计算出主密钥。 会话ID\n这个 Session ID 是可以重用的，具体看服务端资源和支持情况。如果要复用 Session ID， SSL 服务端需要维护连接的状态和上次握手成功留下的加密信息。如果是第一次访问该网址，会话 ID 尚未创建，客户端没记录，为 0。如果客户端保存了 Session ID 的信息，下次发起 SSL 请求的时候会带上。 加密套件\n客户端可以支持的密码套件列表。这些套件会根据优先级排序。每一个套件代表一个密钥规格。以 “TLS” 开头，接着是密钥交换算法，然后用 “WITH” 连接加密算法和认证算法。一个加密套件有这么几个内容：密钥交换算法、加密算法（会带有支持的最高密钥位数）、认证算法还有加密方式。最终使用什么密码套件是服务端决定的。要什么密码套件会在 Server Hello 中进行反馈。 压缩算法\n这里为 0，说明不支持压缩算法 扩展字段\n一些扩展信息，比如 SNI 的支持，ALPN 的信息等等 Server Hello\n类型 版本 指定这次 SSL 使用 TLSv1.2 版本 随机数\n上面的 Client Hello 过程也生产了一个 32 位随机数，这两个随机数将参与主密钥（master key）的创建。（对应图解中随机数2） 会话ID\n加密套件\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 。这个是从客户端 Client Hello 上传的加密套件中选中的，根据密码套件的格式，上面的信息有， 交换加密算法为ECDHE ，就是EC Diffie-Hellman ，RSA 表示后面 Server Key Exchange 阶段的携带 DH 加密算法的公钥的包的数字签名的加密算法是 RSA； 加密算法为 AES ，最高密钥支持 128 位 认证算法 SHA256 压缩方法 这里为 0，表示不使用压缩算法 Certificate\n服务端下发证书，客户端验证服务端的身份，并且取出证书携带的公钥，这个公钥是交换加密算法的公钥。也就是在 Server Hello 阶段指定的 ECDHE （EC Diffie-Hellman）算法，也是通常说的 DH 加密。\n这个 Certificate 消息下发了从携带自己公钥的数字证书和 CA 证书的证书链，在 Certificates 字段中：\n由字段信息可知，证书链中共有2个数字证书。分别为服务端(https://baidu.com)证书 -\u003e 根CA证书。首先看服务端证书\n首先是 signedCertificate 字段的内容，即数字证书的数据\n版本\n对应的就是 X.509 V3 标准 序列号\nserialNumber，证书颁发者唯一序列号。 签名算法ID\n这里指的是使用 SHA-256 进行摘要，RSA 进行加密的签名算法。 证书颁发者\nissuer，就是颁发该证书的 CA 的信息。里面携带后该 CA 的唯一名称（DN，Distinguished Name），比如国家为 US（美国），组织机构为 DigiCert Inc.，名称为 GeoTrust CN RSA CA G1。后面我们需要从证书链找到该 CA 证书（具体方法：在其他证书的subject字段查找国家、组织机构、名称），去认证当前证书 有效期\nvalidity，证书的起始时间和终止时间 对象名称\nsubject，里面就是该证书的名称等主要信息了。比如国家为 CN（中国），组织为Baidu Netcin Science Technology . 对象公钥信息\nsubjectPublicKeyInfo。因为这是服务端证书，这个公钥后面将用于主密钥的交换过程，从中可以了解到这个公钥采用 RSA 加密 扩展部分\n一些扩展信息。比如对象的别名。这个如果是 CDN 的服务器证书，那么别名将会非常多。 然后是证书颁发机构的签名信息：\n签名算法 algorithmIdentifier，这里得出使用的还是 SHA-256 摘要加 RSA 加密的签名算法。这个就是认证该证书的 CA 证书使用的签名算法。 签名信息 encrypted，这个信息的内容，CA 证书对 SHA-256 对上面的数据部分进行摘要后，使用 RSA 的私钥加密获得。后面会用在该证书的认证过程，取出 CA 证书的公钥，解密签名信息，用同样的算法获取数据摘要，对比一下是否相同。 Serve Key Exchange\nServer Hello Done\nClient Key Exchange\nChange Cipher Spec (Client)\nEncrypted Handshake Message (Client)\nChange Cipher Spec (Server)\nEncrypted Handshake Message (Server)\nApplication Data\n0x03 OpenSSL 3.0 环境 系统为ubuntu 16:，IP地址为：192.168.195.149 3.1 OpenSLL安装 OpenSLL编译\n执行命令： tar -xzvf openssl-3.0.0.tar.gz 这里的xzvf参数的含义如下： x：解压tar格式的文件 v：解压时显示详细信息 z：使用gzip程序解压 f：使用归档 配置\n解压完成后检查文件夹\n在文件夹内运行\n./Configure 写一下安装路径的默认规划为\n文件类型 路径 二进制文件 usr\\local\\bin 配置文件 usr\\local\\etc 库文件 usr\\local\\local 编译\n在原来的文件夹里面运行make指令\nmake \u0026 make install 等待输出完成，输入指令\nmake test 可以看到正在进行测试。\n并且最后的测试结果也是通过的。\n最后命令：sudo make install\n3.2 OpenSLL配置 配置完成 编译测试文件\n测试文件源码如下 #include #include int main() { printf(\"hello world!\"); OpenSSL_add_all_algorithms(); return 0; } 加密测试\n源码如下\n#include #include #include #include void tEVP_Encrypt() { unsigned char key[EVP_MAX_KEY_LENGTH];//密钥 unsigned char iv[EVP_MAX_KEY_LENGTH];//初始化向量 /* old usage*/ //EVP_CIPHER_CTX ctx;//EVP算法上下文 /* old usage*/ EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new(); unsigned char out[1024];//输出密文缓冲区 int outl;//密文长度 int outltmp; char *msg=\"Hello OpenSSL\";//待加密的数据 int rv; int i;\t//设置key和iv（可以采用随机数和可以是用户输入） for(i=0;i\u003c24;i++) { key[i]=i; } for(i=0;i\u003c8;i++) {iv[i]=i; }//初始化密码算法结构体 EVP_CIPHER_CTX_init(ctx); //设置算法和密钥以及向量 rv = EVP_EncryptInit_ex(ctx,EVP_des_ede3_cbc(),NULL,key,iv); if(rv!=1) { printf(\"Err\\n\"); return; } //数据加密 rv = EVP_EncryptUpdate(ctx,out,\u0026outl,(const unsigned char*)msg,strlen(msg)); if(rv!=1) { printf(\"Err\\n\"); return; }//结束数据加密，把剩余数据输出 rv = EVP_EncryptFinal_ex(ctx,out+outl,\u0026outltmp); if(rv!=1) { printf(\"Err\\n\"); return; } outl = outl +outltmp; printf(\"Original text:%s\\n\",msg); //打印输出密文 printf(\"Length of ciphertext:%d\\n Data of ciphertext:\\n\",outl); for(i=0;i",
  "wordCount" : "3744",
  "inLanguage": "en",
  "datePublished": "2022-01-01T21:22:48Z",
  "dateModified": "2022-09-11T16:15:05+08:00",
  "author":[{
    "@type": "Person",
    "name": "Reus09"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://www.reus09.top/posts/tech/ssl%E5%88%86%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Reus09's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211103151005.jpeg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://www.reus09.top" accesskey="h" title="Reus09&#39;s Blog (Alt + H)">Reus09&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://www.reus09.top/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/categories" title="🧩分类">
                    <span>🧩分类</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="http://www.reus09.top/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://www.reus09.top">Home</a>&nbsp;»&nbsp;<a href="http://www.reus09.top/posts/">📚文章</a>&nbsp;»&nbsp;<a href="http://www.reus09.top/posts/tech/">👨🏻‍💻技术</a></div>
    <h1 class="post-title">
      Ssl分析
    </h1>
    <div class="post-meta"><span title='2022-01-01 21:22:48 +0000 UTC'>2022-01-01</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Reus09

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#0x01-%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84" aria-label="0x01 实验目的">0x01 实验目的</a></li>
                    <li>
                        <a href="#0x02-tls%e5%8d%8f%e8%ae%ae%e5%88%86%e6%9e%90" aria-label="0x02 TLS协议分析">0x02 TLS协议分析</a></li>
                    <li>
                        <a href="#0x03-openssl" aria-label="0x03 OpenSSL">0x03 OpenSSL</a><ul>
                            
                    <li>
                        <a href="#30-%e7%8e%af%e5%a2%83" aria-label="3.0 环境">3.0 环境</a></li>
                    <li>
                        <a href="#31-opensll%e5%ae%89%e8%a3%85" aria-label="3.1 OpenSLL安装">3.1 OpenSLL安装</a></li>
                    <li>
                        <a href="#32-opensll%e9%85%8d%e7%bd%ae" aria-label="3.2 OpenSLL配置">3.2 OpenSLL配置</a></li>
                    <li>
                        <a href="#33-opensll%e6%b5%8b%e8%af%95" aria-label="3.3 OpenSLL测试">3.3 OpenSLL测试</a></li></ul>
                    </li>
                    <li>
                        <a href="#0x04-%e6%80%bb%e7%bb%93" aria-label="0x04 总结">0x04 总结</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="0x01-实验目的">0x01 实验目的<a hidden class="anchor" aria-hidden="true" href="#0x01-实验目的">#</a></h2>
<ul>
<li>
<p>SSL/TLS协议分析。</p>
<ul>
<li>用wireshark抓包，分析SSL/TLS连接建立的四个阶段。</li>
</ul>
</li>
<li>
<p>OpenSSL安装、配置和测试。</p>
<ul>
<li>安装配置OpenSSL。</li>
<li>配置SSL测试环境，能够在安全连接上发送数据。</li>
</ul>
</li>
</ul>
<h2 id="0x02-tls协议分析">0x02 TLS协议分析<a hidden class="anchor" aria-hidden="true" href="#0x02-tls协议分析">#</a></h2>
<ul>
<li>
<p>源IP：</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213232352.png" alt="image-20211213232344540"  />
</li>
<li>源IP : <code>10.122.201.99</code></li>
</ul>
</li>
<li>
<p>目的域名:<code>www.baidu.com</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213232426.png" alt="image-20211213232426783"  />
</li>
<li>源IP : <code>110.242.68.4</code></li>
</ul>
</li>
<li>
<p>TLS 握手的目的</p>
<ul>
<li>
<p>TCP 三次握手结束和服务器成功连接后，客户端就开始发起TLS连接，首先会进入<strong>TLS握手阶段</strong>。TLS握手阶段目的：</p>
<ul>
<li>
<p><strong>协商加密密钥</strong></p>
<ul>
<li>用来对后面的 HTTP 协议等应用协议内容进行加密。这个密钥又称为主密钥，为加密算法的密钥。</li>
</ul>
</li>
<li>
<p><strong>协商加密算法</strong></p>
<ul>
<li>为了能够提供效率，使用对称密钥。对称加密使用的是位运算，速度快，甚至可以硬件加速。非对称加密比如 RSA，使用了大数乘法等，整体会比较慢。对称加密只要密钥没有泄漏，那也是非常安全的。这也是后面 SSL 握手协议要确保的。</li>
</ul>
</li>
<li>
<p><strong>验证身份及数据完整性</strong></p>
<ul>
<li>通常情况下，只要验证<a href="https://www.zhihu.com/search?q=%E6%9C%8D%E5%8A%A1%E7%AB%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A378880540%7D">服务端</a>身份。特殊情况下，比如一些安全级别高的应用场景，还要验证客户端身份。服务端会返回证书链，有根 CA 证书在里头。通过证书的链式担保，可以确认服务端是否是可信任的。同时，在握手期间，公钥传输成功后，还会对某些信息进行数字签名，确保数据没有被篡改且身份无误。TLS握手阶段一般流程（TLS握手的流程并不是一成不变的，根据实际的应用场景来，主要有三种）：</li>
</ul>
</li>
<li>
<p><strong>只验证服务端</strong></p>
<ul>
<li>这个用三个阶段就完成握手，此次Wireshark的请求也是这样。一般的网络请求也仅仅到这个程度。</li>
</ul>
</li>
<li>
<p><strong>验证服务端和客户端</strong></p>
<ul>
<li>在安全性要求较高的场景，服务端也要验证客户端的身份。方式也是发证书证明自己。</li>
</ul>
</li>
<li>
<p><strong>恢复原有会话</strong></p>
<ul>
<li>这个属于HTTPS 优化的范畴。使用 Session Ticket 或者 Session ID 机制恢复之前已经完成握手的会话。这个是可以允许在不同的 TCP 上进行的。因为握手的加密数据已经保存，直接恢复就可以开始传递了。Session Ticket 由客户端保存加密信息，Session ID 的方式由服务端保存加密信息。不过 Session Ticket 在 Android 客户端还没有得到广泛的支持，和具体机型和内置的 OpenSSL 的版本有关。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TLS握手机制图解</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213232735.jpeg" alt="img"  />
</li>
</ul>
</li>
<li>
<p>Client Hello</p>
<p>在Wireshark软件中捕获了访问百度网页数据包，追踪TCP流得到第一个TLS包</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213233114.png" alt="image-20211213233114871"  />
</li>
<li><strong>类型</strong></li>
<li><strong>长度</strong></li>
<li><strong>版本</strong>
<ul>
<li>TLS 1.2 也是 SSLv3.2。这是 SSL 客户端能够支持的 SSL 最高版本</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong><a href="https://www.zhihu.com/search?q=%E9%9A%8F%E6%9C%BA%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A378880540%7D">随机数</a></strong></p>
<ul>
<li>生成一个32字节随机数（图中的随机数）。最后加密数据用的主密钥，需要客户端和服务端一起协商出来。后面服务端的 Server Hello 阶段也会生成一个随机数。一同用来计算出主密钥。</li>
</ul>
</li>
<li>
<p><strong>会话ID</strong></p>
<ul>
<li>这个 Session ID 是可以重用的，具体看服务端资源和支持情况。如果要复用 Session ID， SSL 服务端需要维护连接的状态和上次握手成功留下的加密信息。如果是第一次访问该网址，会话 ID 尚未创建，客户端没记录，为 0。如果客户端保存了 Session ID 的信息，下次发起 SSL 请求的时候会带上。</li>
</ul>
</li>
<li>
<p><strong>加密套件</strong></p>
<ul>
<li>客户端可以支持的密码套件列表。这些套件会根据优先级排序。每一个套件代表一个密钥规格。以 “TLS” 开头，接着是<a href="https://www.zhihu.com/search?q=%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A378880540%7D">密钥交换算法</a>，然后用 “WITH” <a href="https://www.zhihu.com/search?q=%E8%BF%9E%E6%8E%A5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A378880540%7D">连接加密算法</a>和认证算法。一个加密套件有这么几个内容：密钥交换算法、加密算法（会带有支持的最高密钥位数）、认证算法还有加密方式。最终使用什么密码套件是服务端决定的。要什么密码套件会在 Server Hello 中进行反馈。</li>
</ul>
</li>
<li>
<p><strong>压缩算法</strong></p>
<ul>
<li>这里为 0，说明不支持压缩算法</li>
</ul>
</li>
<li>
<p><strong>扩展字段</strong></p>
<ul>
<li>一些扩展信息，比如 SNI 的支持，ALPN 的信息等等</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Server Hello</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213233336.png" alt="image-20211213233311508"  />
</li>
<li><strong>类型</strong></li>
<li><strong>版本</strong>
<ul>
<li>指定这次 SSL 使用 TLSv1.2 版本</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong>随机数</strong></p>
<ul>
<li>上面的 Client Hello 过程也生产了一个 32 位随机数，这两个随机数将参与主密钥（master key）的创建。（对应图解中随机数2）</li>
</ul>
</li>
<li>
<p><strong>会话ID</strong></p>
</li>
<li>
<p><strong>加密套件</strong></p>
<ul>
<li><strong>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</strong> 。这个是从客户端 Client Hello 上传的加密套件中选中的，根据密码套件的格式，上面的信息有，
<ul>
<li>交换加密算法为ECDHE ，就是EC Diffie-Hellman ，RSA 表示后面 Server Key Exchange 阶段的携带 DH 加密算法的公钥的包的数字签名的加密算法是 RSA；</li>
<li>加密算法为 AES ，最高密钥支持 128 位</li>
<li>认证算法 SHA256</li>
<li><strong>压缩方法</strong>
<ul>
<li>这里为 0，表示不使用压缩算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Certificate</p>
<ul>
<li>
<p>服务端下发证书，客户端验证服务端的身份，并且取出证书携带的公钥，这个公钥是交换加密算法的公钥。也就是在 Server Hello 阶段指定的 ECDHE （EC Diffie-Hellman）算法，也是通常说的 DH 加密。</p>
</li>
<li>
<p>这个 Certificate 消息下发了从携带自己公钥的数字证书和 CA 证书的证书链，在 Certificates 字段中：</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213233423.png" alt="image-20211213233423017"  />
</p>
</li>
<li>
<p>由字段信息可知，证书链中共有2个数字证书。分别为服务端(<a href="https://baidu.com/">https://baidu.com</a>)证书 -&gt;  根CA证书。首先看服务端证书</p>
</li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213233622.png" alt="image-20211213233622841"  />
</p>
</li>
<li>
<p>首先是 signedCertificate 字段的内容，即数字证书的数据</p>
<ul>
<li>
<p><strong>版本</strong></p>
<ul>
<li>对应的就是 X.509 V3 标准</li>
</ul>
</li>
<li>
<p><strong>序列号</strong></p>
<ul>
<li>serialNumber，证书颁发者唯一序列号。</li>
</ul>
</li>
<li>
<p><strong>签名算法ID</strong></p>
<ul>
<li>这里指的是使用 SHA-256 进行摘要，RSA 进行加密的签名算法。</li>
</ul>
</li>
<li>
<p><strong>证书颁发者</strong></p>
<ul>
<li>issuer，就是颁发该证书的 CA 的信息。里面携带后该 CA 的唯一名称（DN，Distinguished Name），比如国家为 US（美国），组织机构为 DigiCert Inc.，名称为 GeoTrust CN RSA CA G1。后面我们需要从证书链找到该 CA 证书（具体方法：在其他证书的subject字段查找国家、组织机构、名称），去认证当前证书</li>
</ul>
</li>
<li>
<p><strong>有效期</strong></p>
<ul>
<li>validity，证书的起始时间和终止时间</li>
</ul>
</li>
<li>
<p><strong>对象名称</strong></p>
<ul>
<li>subject，里面就是该证书的名称等主要信息了。比如国家为 CN（中国），组织为Baidu Netcin Science Technology .</li>
</ul>
</li>
<li>
<p><strong>对象公钥信息</strong></p>
<ul>
<li>subjectPublicKeyInfo。因为这是服务端证书，这个公钥后面将用于主密钥的交换过程，从中可以了解到这个公钥采用 RSA 加密</li>
</ul>
</li>
<li>
<p><strong>扩展部分</strong></p>
<ul>
<li>一些扩展信息。比如对象的别名。这个如果是 CDN 的服务器证书，那么别名将会非常多。</li>
</ul>
</li>
</ul>
<p>然后是证书颁发机构的签名信息：</p>
<ul>
<li><strong>签名算法</strong>
<ul>
<li>algorithmIdentifier，这里得出使用的还是 SHA-256 摘要加 RSA 加密的签名算法。这个就是认证该证书的 CA 证书使用的签名算法。</li>
<li><strong>签名信息</strong>
<ul>
<li>encrypted，这个信息的内容，CA 证书对 SHA-256 对上面的数据部分进行摘要后，使用 RSA 的私钥加密获得。后面会用在该证书的认证过程，取出 CA 证书的公钥，解密签名信息，用同样的算法获取数据摘要，对比一下是否相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Serve Key Exchange</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213233721.png" alt="image-20211213233721653"  />
</li>
</ul>
</li>
<li>
<p>Server Hello Done</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213233751.png" alt="image-20211213233750769"  />
</li>
</ul>
</li>
<li>
<p>Client Key Exchange</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213234146.png" alt="image-20211213234146899"  />
</li>
</ul>
</li>
<li>
<p>Change Cipher Spec (Client)</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213234203.png" alt="image-20211213234203037"  />
</li>
</ul>
</li>
<li>
<p>Encrypted Handshake Message (Client)</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213234218.png" alt="image-20211213234218138"  />
</li>
</ul>
</li>
<li>
<p>Change Cipher Spec (Server)</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213234310.png" alt="image-20211213234310334"  />
</li>
</ul>
</li>
<li>
<p>Encrypted Handshake Message (Server)</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213234335.png" alt="image-20211213234335493"  />
</li>
</ul>
</li>
<li>
<p>Application Data</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211213234410.png" alt="image-20211213234410671"  />
</li>
</ul>
</li>
</ul>
<h2 id="0x03-openssl">0x03 OpenSSL<a hidden class="anchor" aria-hidden="true" href="#0x03-openssl">#</a></h2>
<h3 id="30-环境">3.0 环境<a hidden class="anchor" aria-hidden="true" href="#30-环境">#</a></h3>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214235405.png" alt=""  />
</li>
<li>系统为<code>ubuntu 16</code>:，IP地址为：<code>192.168.195.149</code></li>
</ul>
<h3 id="31-opensll安装">3.1 OpenSLL安装<a hidden class="anchor" aria-hidden="true" href="#31-opensll安装">#</a></h3>
<ul>
<li>
<p>OpenSLL编译</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214223728.png" alt="image-20211214223728298"  />
</li>
<li>执行命令： <code>tar -xzvf openssl-3.0.0.tar.gz</code></li>
<li>这里的xzvf参数的含义如下：
<ul>
<li>x：解压tar格式的文件</li>
<li>v：解压时显示详细信息</li>
<li>z：使用gzip程序解压</li>
<li>f：使用归档</li>
</ul>
</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214223806.png" alt="image-20211214223806813"  />
</li>
</ul>
</li>
<li>
<p>配置</p>
<ul>
<li>
<p>解压完成后检查文件夹</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214223834.png" alt="image-20211214223834428"  />
</li>
</ul>
</li>
<li>
<p>在文件夹内运行</p>
<p><code>./Configure </code></p>
<ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214223931.png" alt="image-20211214223931802"  />
</p>
</li>
<li>
<p>写一下安装路径的默认规划为</p>
<table>
<thead>
<tr>
<th style="text-align:left">文件类型</th>
<th style="text-align:left">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">二进制文件</td>
<td style="text-align:left">usr\local\bin</td>
</tr>
<tr>
<td style="text-align:left">配置文件</td>
<td style="text-align:left">usr\local\etc</td>
</tr>
<tr>
<td style="text-align:left">库文件</td>
<td style="text-align:left">usr\local\local</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编译</p>
<ul>
<li>
<p>在原来的文件夹里面运行make指令</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>make &amp; make install
</span></span></code></pre></div></li>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214224041.png" alt="image-20211214224041691"  />
</p>
</li>
<li>
<p>等待输出完成，输入指令</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>make test
</span></span></code></pre></div></li>
<li>
<p>可以看到正在进行测试。</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214224544.png" alt="image-20211214224544440"  />
</li>
</ul>
</li>
<li>
<p>并且最后的测试结果也是通过的。</p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214225026.png" alt="image-20211214225026263"  />
</li>
</ul>
</li>
<li>
<p>最后命令：<code>sudo make install</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214225122.png" alt="image-20211214225122665"  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="32-opensll配置">3.2 OpenSLL配置<a hidden class="anchor" aria-hidden="true" href="#32-opensll配置">#</a></h3>
<ul>
<li>
<p><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214230506.png" alt="image-20211214230506469"  />
</p>
<ul>
<li>配置完成</li>
</ul>
</li>
<li>
<p>编译测试文件</p>
<ul>
<li>测试文件源码如下</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;stdio.h&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;evp.h&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>printf(<span style="color:#0ff;font-weight:bold">&#34;hello world!&#34;</span>);
</span></span><span style="display:flex;"><span>OpenSSL_add_all_algorithms();
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214231801.png" alt="image-20211214231801499"  />
</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214231920.png" alt="image-20211214231920233"  />
</li>
</ul>
</li>
<li>
<p>加密测试</p>
<ul>
<li>
<p>源码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;stdio.h&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string.h&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;openssl/evp.h&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;openssl/x509.h&gt; </span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span><span style="color:#fff;font-weight:bold">void</span> tEVP_Encrypt()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> key[EVP_MAX_KEY_LENGTH];<span style="color:#007f7f">//密钥
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> iv[EVP_MAX_KEY_LENGTH];<span style="color:#007f7f">//初始化向量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#007f7f">/* old usage*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">//EVP_CIPHER_CTX ctx;//EVP算法上下文
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#007f7f">/* old usage*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> out[<span style="color:#ff0;font-weight:bold">1024</span>];<span style="color:#007f7f">//输出密文缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">int</span> outl;<span style="color:#007f7f">//密文长度
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">int</span> outltmp;
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">char</span> *msg=<span style="color:#0ff;font-weight:bold">&#34;Hello OpenSSL&#34;</span>;<span style="color:#007f7f">//待加密的数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">int</span> rv;
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">int</span> i;	
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">//设置key和iv（可以采用随机数和可以是用户输入）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">for</span>(i=<span style="color:#ff0;font-weight:bold">0</span>;i&lt;<span style="color:#ff0;font-weight:bold">24</span>;i++)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		key[i]=i;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">for</span>(i=<span style="color:#ff0;font-weight:bold">0</span>;i&lt;<span style="color:#ff0;font-weight:bold">8</span>;i++)
</span></span><span style="display:flex;"><span>	{iv[i]=i;
</span></span><span style="display:flex;"><span>	}<span style="color:#007f7f">//初始化密码算法结构体
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	EVP_CIPHER_CTX_init(ctx);
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">//设置算法和密钥以及向量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	rv = EVP_EncryptInit_ex(ctx,EVP_des_ede3_cbc(),<span style="color:#fff;font-weight:bold">NULL</span>,key,iv);
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span>(rv!=<span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		printf(<span style="color:#0ff;font-weight:bold">&#34;Err</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">//数据加密
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	rv = EVP_EncryptUpdate(ctx,out,&amp;outl,(<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span>*)msg,strlen(msg));
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span>(rv!=<span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		printf(<span style="color:#0ff;font-weight:bold">&#34;Err</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>	}<span style="color:#007f7f">//结束数据加密，把剩余数据输出
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	rv = EVP_EncryptFinal_ex(ctx,out+outl,&amp;outltmp);
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span>(rv!=<span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		printf(<span style="color:#0ff;font-weight:bold">&#34;Err</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	outl = outl +outltmp;
</span></span><span style="display:flex;"><span>	printf(<span style="color:#0ff;font-weight:bold">&#34;Original text:%s</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>,msg);
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">//打印输出密文
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>printf(<span style="color:#0ff;font-weight:bold">&#34;Length of ciphertext:%d</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold"> Data of ciphertext:</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>,outl);
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">for</span>(i=<span style="color:#ff0;font-weight:bold">0</span>;i&lt;outl;i++)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		printf(<span style="color:#0ff;font-weight:bold">&#34;0x%02x &#34;</span>,out[i]);
</span></span><span style="display:flex;"><span>	}printf(<span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>	OpenSSL_add_all_algorithms();
</span></span><span style="display:flex;"><span>	tEVP_Encrypt();
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>编译：<code>g++ test2.cpp -o test2 -I /usr/local/include/openssl/ -lcrypto -lssl</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214232531.png" alt="在这里插入图片描述"  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="33-opensll测试">3.3 OpenSLL测试<a hidden class="anchor" aria-hidden="true" href="#33-opensll测试">#</a></h3>
<ul>
<li>
<p>这里通过<code>python</code>代码进行演示 TLS连接</p>
<ul>
<li>
<p>服务端</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> ssl
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> server_ssl:
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">def</span> build_listen(self):
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f"># 生成SSL上下文</span>
</span></span><span style="display:flex;"><span>        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f"># 加载服务器所用证书和私钥</span>
</span></span><span style="display:flex;"><span>        context.load_cert_chain(<span style="color:#0ff;font-weight:bold">&#39;server.crt&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;key.pem&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 监听端口</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM, <span style="color:#ff0;font-weight:bold">0</span>) <span style="color:#fff;font-weight:bold">as</span> sock:
</span></span><span style="display:flex;"><span>        sock.bind((<span style="color:#0ff;font-weight:bold">&#39;192.168.195.149&#39;</span>,<span style="color:#ff0;font-weight:bold">7777</span>))
</span></span><span style="display:flex;"><span>        sock.listen(<span style="color:#ff0;font-weight:bold">5</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f"># 将socket打包成SSL socket</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">with</span> context.wrap_socket(sock, server_side=<span style="color:#fff;font-weight:bold">True</span>) <span style="color:#fff;font-weight:bold">as</span> ssock:
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">while</span> <span style="color:#fff;font-weight:bold">True</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#007f7f"># 接收客户端连接</span>
</span></span><span style="display:flex;"><span>                client_socket, addr = ssock.accept()
</span></span><span style="display:flex;"><span>                msg = client_socket.recv(<span style="color:#ff0;font-weight:bold">1024</span>).decode(<span style="color:#0ff;font-weight:bold">&#34;utf-8&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#34;receive msg from client </span><span style="color:#0ff;font-weight:bold">{</span>addr<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">：</span><span style="color:#0ff;font-weight:bold">{</span>msg<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#007f7f"># 向客户端发送信息</span>
</span></span><span style="display:flex;"><span>                msg = <span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#34;yes , you have client_socketect with     server.</span><span style="color:#0ff;font-weight:bold">\r\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>.encode(<span style="color:#0ff;font-weight:bold">&#34;utf-8&#34;</span> )
</span></span><span style="display:flex;"><span>                client_socket.send(msg)
</span></span><span style="display:flex;"><span>                client_socket.close()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> __name__ == <span style="color:#0ff;font-weight:bold">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    server = server_ssl()
</span></span><span style="display:flex;"><span>    server.build_listen()  
</span></span></code></pre></div></li>
<li>
<p>客户端代码</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> ssl
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> client_ssl:
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">def</span> send_hello(self,):
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f"># 生成SSL上下文</span>
</span></span><span style="display:flex;"><span>        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f"># 加载信任根证书</span>
</span></span><span style="display:flex;"><span>        context.load_verify_locations(<span style="color:#0ff;font-weight:bold">&#39;ca.crt&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">#与服务端建立socket连接</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">with</span> socket.create_connection((<span style="color:#0ff;font-weight:bold">&#39;192.168.195.149&#39;</span>,<span style="color:#ff0;font-weight:bold">7777</span>)) <span style="color:#fff;font-weight:bold">as</span> sock:
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f"># 将socket打包成SSL socket</span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f"># 一定要注意的是这里的server_hostname不是指服务端IP，而是指服务端证书中设置的CN</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">with</span> context.wrap_socket(sock, server_hostname=<span style="color:#0ff;font-weight:bold">&#39;127.0.0.1&#39;</span>) <span style="color:#fff;font-weight:bold">as</span> ssock:
</span></span><span style="display:flex;"><span>            msg = <span style="color:#0ff;font-weight:bold">&#34;do i connect with server ?&#34;</span>.encode(<span style="color:#0ff;font-weight:bold">&#34;utf-8&#34;</span>)
</span></span><span style="display:flex;"><span>            ssock.send(msg)
</span></span><span style="display:flex;"><span>            <span style="color:#007f7f"># 接收服务端返回的信息</span>
</span></span><span style="display:flex;"><span>            msg = ssock.recv(<span style="color:#ff0;font-weight:bold">1024</span>).decode(<span style="color:#0ff;font-weight:bold">&#34;utf-8&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#34;receive msg from server : </span><span style="color:#0ff;font-weight:bold">{</span>msg<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
</span></span><span style="display:flex;"><span>            ssock.close()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> __name__ == <span style="color:#0ff;font-weight:bold">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    client = client_ssl()
</span></span><span style="display:flex;"><span>    client.send_hello() 
</span></span></code></pre></div></li>
<li>
<p>这里的证书我采取自己生成</p>
<ul>
<li>
<p>进入Ubuntu <code>desktop</code>，文件名为<code>key</code></p>
<p><code>mkdir key</code></p>
</li>
<li>
<p>生成CA私钥
<code>openssl genrsa -out ca.key 2048</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214233749.png" alt="image-20211214233749915"  />
</li>
</ul>
</li>
<li>
<p>用CA私钥生成CA的证书
<code>openssl req -new -x509 -days 365 -key ca.key -out ca.crt</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214233856.png" alt="image-20211214233856750"  />
</li>
</ul>
</li>
<li>
<p>建立CA相应目录进入到key文件夹执行如下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>mkdir demoCA
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">cd</span> demoCA
</span></span><span style="display:flex;"><span>mkdir newcerts
</span></span><span style="display:flex;"><span>touch index.txt
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">echo</span> ‘01’ &gt; serial
</span></span></code></pre></div><ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214234026.png" alt="image-20211214234026346"  />
</li>
</ul>
</li>
<li>
<p>生成server端证书</p>
<ul>
<li>
<p>进入key文件夹,生成server私钥</p>
<p><code>openssl genrsa -out server.key 2048</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214234142.png" alt="image-20211214234142390"  />
</li>
</ul>
</li>
<li>
<p>使用server私钥生成server端证书请求文件: <code>openssl req -new -key server.key -out server.csr</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214234250.png" alt="image-20211214234250330"  />
</li>
</ul>
</li>
<li>
<p>使用server证书请求文件通过CA生成自签名证书</p>
<p><code>openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214234359.png" alt="image-20211214234359545"  />
</li>
</ul>
</li>
<li>
<p>验证server证书</p>
<p><code>openssl verify -CAfile ca.crt server.crt</code></p>
<ul>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214234432.png" alt="image-20211214234432765"  />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>结果</p>
<ul>
<li>生成了正确的证书文件后，笔者把文件加载到程序中，设置ip地址为当前的ipv4的地址，设置端口，一台电脑先运行服务器，一台电脑再运行客户端，运行成功，结果如下：</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214235001.png" alt="image-20211214235000916"  />
</li>
<li><img loading="lazy" src="https://cnblog-img-reus09.oss-cn-beijing.aliyuncs.com/image/20211214235017.png" alt="image-20211214235017795"  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x04-总结">0x04 总结<a hidden class="anchor" aria-hidden="true" href="#0x04-总结">#</a></h2>
<ul>
<li>通过Wireshark对TLS的三次握手过程进行分析，对TLS的作用机理理解更为透彻。</li>
<li>通过<code>Ubuntu</code>中对<code>openssl</code>工具的配置，并且分别利用<code>c</code>和<code>python</code>对<code>openssl</code>进行实际练习，对<code>ssl</code>的作用过程更为明晰。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://www.reus09.top/tags/ssl/">ssl</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://www.reus09.top/posts/tech/jdbc/">
    <span class="title">« Prev</span>
    <br>
    <span>Jdbc</span>
  </a>
  <a class="next" href="http://www.reus09.top/posts/tech/vpn%E9%85%8D%E7%BD%AE/">
    <span class="title">Next »</span>
    <br>
    <span>Vpn配置</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="http://www.reus09.top">Reus09&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
